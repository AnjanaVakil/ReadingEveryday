## Chapter 8 对象

Reids基于基本数据结构创建了一个对象系统。

对象系统还实现了：

* 基于`引用计数`的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；
* 通过引用计数实现了`对象共享`机制，这一机制可以在适当的条件下，通过让多个数据库`键`共享`同一个对象`来节约内存。

### 8.1 对象的类型与编码

```c
typedef struct redisObject{
  unsigned type:4;
  unsigned encoding:4;
  void *ptr;
}robj;
```

key：字符串对象

value：字符串对象/列表对象/哈希对象/集合对象/有序集合对象

TYPE 命令的输出：string/list/hash/set/zset

### 8.2 字符串对象

字符串对象的编码可以是int/raw/embstr。

embstr编码是专门用于保存`短字符串`的一种优化编码方式，这种编码和raw编码一样，都使用`redisObject`结构和`sdshdr`结构来表示字符串对象，但

* raw编码
  * 字符串的长度>32B
  * 会调用`两次内存分配函数`来分别创建redisObject结构和sdshdr结构
* embstr编码
  * 字符串的长度<32B
  * 调用`一次内存分配函数`来分配一块`连续的空间`，空间中依次包含redisObject和sdshdr两个结构

因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有`int编码的字符串对象`和`raw编码的字符串对象`有这些程序），所以`embstr编码的字符串对象实际上是只读`的。当对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。

### 8.3 列表对象

列表对象的编码：ziplist或者linkedlist。

### 8.4 哈希对象

哈希对象的编码：ziplist或者hashtable。

### 8.5 集合对象

集合对象的编码：intset或者hashtable。

### 8.6 有序集合对象

有序集合的编码：ziplist或者skiplist。

skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表

### 8.7 类型检查与命令多态

 DEL、EXPIRE等命令和LLEN等命令的区别在于：

* 前者是基于类型的多态：一个命令可以同时用于处理多种不同类型的键
* 后者是基于编码的多态：一个命令可以同时用于处理多种不同编码

### 8.9 对象共享

目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键A。

另外，这些共享对象不单单只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象，以及zset编码的有序集合对象）都可以使用这些共享对象。

因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对`包含整数值的字符串对象`进行共享。