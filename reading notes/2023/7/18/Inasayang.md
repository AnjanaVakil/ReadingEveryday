内存块

内存块（memory block）

-   一个内存块是一段在运行时刻承载着若干值部的连续内存片段
-   不同的内存块的大小可能不同，因它们所承载的值部的尺寸而定
-   一个内存块同时可能承载着不同Go值的若干值部，但是一个值部在内存中绝不会跨内存块存储，无论此值部的尺寸有多大
-   一个内存块可能承载若干值部的原因有很多
    -   一个结构体值很可能有若干字段，所以当为此结构体值开辟了一个内存块时，此内存块同时也将承载此结构体值的各个字段值（的直接部分）
    -   一个数组值常常包含很多元素，所以当为此数组值开辟了一个内存块时，此内存块同时也将承载此数组值的各个元素值（的直接部分）
    -   两个切片的底层间接部分的元素序列可能承载在同一个内存块上，这两个间接值部甚至可能有部分重叠



什么时候需要开辟内存块？

-   显式地调用`new`和`make`内置函数
    -   一个`new`函数调用总是只开辟一个内存块
    -   一个`make`函数调用有可能会开辟多个内存块来承载创建的切片/映射/通道值的直接和底层间接值部
-   使用字面量创建映射、切片或函数值。在此创建过程中，一个或多个内存块将被开辟出来
-   声明变量
-   将一个非接口值赋给一个接口值。（对于标准编译器来说，不包括将一个指针值赋给一个接口值的情况。）
-   衔接非常量字符串
-   将字符串转换为字节切片或者码点切片，或者反之，除了一些编译器优化情形
-   将一个整数转换为字符串
-   调用内置`append`函数并且基础切片的容量不足够大
-   向一个映射添加一个键值条目并且此映射底层内部的哈希表需要改变容量



内存块将被开辟在何处？

-   对每一个使用标准编译器编译的Go程序，在运行时刻，每一个协程将维护一个栈（`stack`）

-   一个栈是一个预申请的内存段，它做为一个内存池供某些内存块从中开辟

-   在官方Go工具链1.19版本之前，一个栈的初始尺寸总是2KiB。 从1.19版本开始，栈的初始尺寸是自适应的
    （https://docs.google.com/document/d/1YDlGIdVTPnmUiTAavlZxBI1d9pwGQgZT7IKFKlIXohQ）

-   每个栈的尺寸在协程运行的时候将按照需要增长和收缩

-   栈的最小尺寸为`2KiB`

    

>   Go运行时维护着一个协程栈的最大尺寸限制，此限制为全局的
>
>   如果一个协程在增长它的栈的时候超过了此限制，整个程序将崩溃
>
>   对于目前的官方标准Go工具链1.20版本，此最大限制的默认值在64位系统上为1GB，在32位系统上为250MB
>
>   在运行时刻调用`runtime/debug`标准库包中的`SetMaxStack`来修改此值
>
>   当前的官方标准编译器实现中，实际上允许的协程栈的最大尺寸为不超过最大尺寸限制的2的幂
>
>   所以对于默认设置，实际上允许的协程栈的最大尺寸在64位系统上为512MiB，在32位系统上为128MiB

-   内存块可以被开辟在栈上。开辟在一个协程维护的栈上的内存块只能在此协程内部被使用（引用）



-   堆（`heap`）是一个虚拟的概念。每个程序只有一个堆
-   一般地，如果一个内存块没有开辟在任何一个栈上，则我们说它开辟在了堆上
-   开辟在堆上的内存块可以被多个协程并发地访问
-   如果编译器觉察到一个内存块在运行时将会被多个协程访问，或者不能轻松地断定此内存块是否只会被一个协程访问，则此内存块将会被开辟在堆上(编译器将采取保守但安全的策略，使得某些可以安全地被开辟在栈上的内存块也有可能会被开辟在堆上)
-   事实上，栈对于Go程序来说并非必要。Go程序中所有的内存块都可以开辟在堆上。支持栈只是为了让Go程序的运行效率更高
    -   从栈上开辟内存块比在堆上快得多
    -   开辟在栈上的内存块不需要被垃圾回收
    -   开辟在栈上的内存块对CPU缓存更加友好
-   可以运行Go官方工具链中提供的`go build -gcflags -m`命令来查看代码中哪些局部值的值部在运行时刻会逃逸到堆上
-   可以认为每个包级变量（常称全局变量）都被开辟在了堆上，并且它被一个开辟在一个全局内存区上的隐式指针所引用着。事实上，此指针引用着此包级变量的直接部分，此直接部分又引用着其它的值（部）
-   一些事实
    -   如果一个结构体值的一个字段逃逸到了堆上，则此整个结构体值也逃逸到了堆上
    -   如果一个数组的某个元素逃逸到了堆上，则此整个数组也逃逸到了堆上
    -   如果一个切片的某个元素逃逸到了堆上，则此切片中的所有元素都将逃逸到堆上，但此切片值的直接部分可能开辟在栈上
    -   如果一个值部v被一个逃逸到了堆上的值部所引用，则此值部v也将逃逸到堆上
-   内置new函数开辟的内存可能开辟在堆上，也可能开辟在栈上。这是与C++不同的一点



当一个协程的栈的大小（因为栈增长或者收缩而）改变时，一个新的内存段将申请给此栈使用

原先已经开辟在老的内存段上的内存块将很有可能被转移到新的内存段上，或者说这些内存块的地址将改变

相应地，引用着这些开辟在此栈上的内存块的指针（它们同样开辟在此栈上）中存储的地址也将得到刷新

```
//go:noinline
func f(i int) byte {
	var a [1<<20]byte // 使栈增长
	return a[i]
}
func main(){
	var x int
	println(&x)
	f(100)
	println(&x)
}
```

打引出的两个地址不一样



Pp. 456-460