一个内存块在什么条件下可以被回收？

-   为包级变量的直接部分开辟的内存块永远不会被回收
-   每个协程的栈将在此协程退出之时被整体回收，此栈上开辟的各个内存块没必要被一个一个单独回收。 栈内存池并不由垃圾回收器回收
-   对一个开在堆上的内存块，当它不再被任何开辟在协程栈的仍被使用中的，以及全局内存区上的，值部所（直接或者间接）地引用着，则此内存块可以被安全地垃圾回收了
-   开辟在堆上的不再被使用的内存块将在以后某个时刻被垃圾回收器回收掉
-   使用`runtime.KeepAlive`函数调用以便让垃圾回收器知晓在此调用之前仍在被使用中



如何判断一个堆内存块是否仍在被使用？

-   使用一个并发三色（tri-color）标记清扫（mark-sweep）算法（https://blog.golang.org/go15gc）来实现垃圾回收
-   一个垃圾回收过程分为两个阶段：标记阶段和清扫阶段
    -   标记阶段：垃圾回收器（实际上是一组协程）使用三色算法来分析哪些（开辟在堆上的）内存块已经不再使用了
        -   在每一轮垃圾回收过程的开始，所有的堆内存块将被标记为白色
        -   然后垃圾回收器将所有开辟在栈和全局内存区上的内存块标记为灰色，并把它们加入一个灰色内存块列表
        -   循环下面两步直到灰色内存块列表为空
            -   从个灰色内存块列表中取出一个内存块，并把它标记为黑色
            -   然后扫描承载在此内存块上的指针值，并通过这些指针找到它们引用着的内存块。 如果一个引用着的内存块为白色的，则将其标记为灰色并加入灰色内存块列表；否则，忽略之
        -   使用三色而不是两色的原因是此标记过程是并发的
        -   在标记的过程中，很多其它普通用户协程也正在运行中
        -   在此标记过程中对指针的写入需要一些额外的开销（write barrier golang）
    -   清扫阶段：仍被标记为白色的内存块将被认为不再使用而被回收掉
        -   一个不再被使用的内存块被回收后可能并不会立即释放给操作系统，这样Go运行时可以将其重新分配给其它值部使用

不再被使用的内存块将在什么时候被回收？

-   关于GOGC和GOMEMLIMIT环境变量（https://golang.org/pkg/runtime/#hdr-Environment_Variables）
-   A Guide to the Go Garbage Collector（https://go.dev/doc/gc-guide）
-   GC Pacer Redesign（https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md）
-   Go编程优化101（https://gfw.go101.org/optimizations/101.html）



Pp. 460-464