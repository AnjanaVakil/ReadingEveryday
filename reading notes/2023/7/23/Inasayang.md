64位字原子操作的地址对齐保证要求

-   64位字是指类型为内置类型int64或uint64的值
-   Go 1.19引入了一种更为优雅的方法来保证一些值的地址对齐保证为8字节
    -   `atomic.Int64`和`atomic.Uint64`
    -   这两个类型的值在内存中总是8字节对齐的，即使在32位架构上也是如此



子字符串造成的暂时性内存泄露

-   一个子字符串表达式的结果（子）字符串和基础字符串可能共享一个承载底层字节序列的内存块
-   这是一个好的设计，它不仅节省内存，而且还减少了CPU消耗。 但是有时候会造成暂时性的内存泄露

​	

```
var s0 string // 一个包级变量

// 一个演示目的函数。
func f(s1 string) {
	s0 = s1[:50]
	// 目前，s0和s1共享着承载它们的字节序列的同一个内存块。
	// 虽然s1到这里已经不再被使用了，但是s0仍然在使用中，
	// 所以它们共享的内存块将不会被回收。虽然此内存块中
	// 只有50字节被真正使用，而其它字节却无法再被使用。
}
func demo() {
	s := createStringWithLengthOnHeap(1 << 20) // 1M bytes
	f(s)
}
```

防止上面的f函数产生临时性内存泄露，可以将子字符串表达式的结果转换为一个字节切片，然后再转换回来

```
func f(s1 string) {
	s0 = string([]byte(s1[:50]))
}
```

不是很高效，因为在此过程中底层的字节序列被复制了两次，其中一次是不必要的

可以利用官方Go标准编译器对字符串衔接所做的优化来防止一次不必要的复制，代价是有一个字节的浪费

```
func f(s1 string) {
	s0 = (" " + s1[:50])[1:]
}
```

有可能在将来会失效

使用`strings.Builder`类型来防止一次不必要的复制

```
func f(s1 string) {
	var b strings.Builder
	b.Grow(50)
	b.WriteString(s1[:50])
	s0 = b.String()
}
```



Pp. 468-473