关于spin lock流程如下:

尝试获得rw-lock锁:

成功 ， 直接返回

不成功，进入循环

开始循环

开始旋转N轮。（这里N由innodb_sync_spin_loops定义和控制）。默认值为30发。

步骤3a：每回合将调用PAUSE逻辑，这将导致CPU在X周期内进入PAUSE。

步骤3b：在每个回合后发布一次软检查，以确认是否有上述锁可用（busy-wait）。

如果可用，则旋转周期退出。

步骤3c：再次尝试获取所需的锁。

如果成功，则返回。（spins=1, rounds=M (M <= N), os-waits=0）

如果失败，并且有一些待处理的回合（max = innodb_sync_spin_loops），则继续旋转。（如何中断循环并导致锁定失败。注意：并行由多个线程查看该锁。虽然在尝试获取该锁时，多个线程已收到有关锁可用性的信号，但其他线程却接过了该锁因此，该线程现在返回重试）。

步骤3d：说一个线程现在完成了它的旋转等待轮，甚至现在它也没有获得锁。进一步旋转和浪费CPU周期没有任何意义。更好地放弃待处理的CPU周期，将其返回给OS，让OS调度做必要的事情。而且，由于所述线程现在要进入睡眠状态，因此应该在一些通用基础结构中注册自己，这将在有可用所述锁定时帮助其发回活动状态。

步骤3e：将线程基础结构通过信号发回到Innodb活动状态的同步阵列基础结构中

所述线程通过在所述阵列中保留插槽来注册自身。

在开始等待之前，请再次尝试查看该锁是否可用。（因为预订可能很耗时，并且锁可能同时可用）。

如果仍然没有锁，则等待同步阵列基础结构发信号通知该线程。

此等待称为OS等待，进入此循环现在将导致OS等待计数增加。

步骤3f：说该线程由同步阵列基础结构发信号通知等待事件。重试以获得所需的锁。

如果成功，则返回。（spins=1, rounds=N, os-waits=1）

如果失败，则整个循环从旋转逻辑重新启动（返回到第3步，并将回合计数重新初始化为0）。注意：spin次数不会重新增加。
