## 安全区域

处于阻塞的线程无法响应中断虚拟机的中断请求，所以安全点的设计并没有解决阻塞（或者sleep的线程）的线程如何进入安全点的问题。

安全区域是指能够确保在某一段代码片段中，引用关系不会再发生变化，因此在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

- 当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，虚拟机会忽略掉这些在安全区域的线程。
- 当退出时会检查虚拟机是否完成了根节点枚举，直到收到可以离开安全区域的信号为止。

## 记忆集与卡表

之前讲到跨代引用，为了避免少量的跨代去扫描整个老年代，只需要在新生代上建立一个全局的数据结构。

这个数据结构就是「记忆集」（Remembered Set）。记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

HotSpot使用了一种称为「卡表」的方式实现「记忆集」的。

卡表：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

卡表的最简单形式为一个字节数组：

```c
CARD_TABLE[this address >> 9] = 1;
```

CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页（Card Page）。

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或多个对象的字段存在跨代指针，那么就将对应卡表的数组元素的值标识为1。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

## 写屏障

解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏，谁来把它们变脏等。

- 何时变脏：当有其他分代区域中对象引用了本区域对象时，引用字段赋值的哪一刻就是变脏的时间点
- 如何变脏：如何在对象赋值的哪一刻去更新维护卡表呢？

- - 解释执行的代码，有充分的介入空间
- 编译执行的代码：写屏障



写屏障（Write Barrier）可以看作虚拟机层面对「引用类型字段赋值」这个动作对AOP切面。

写前屏障：赋值前的写屏障

写后屏障：赋值后的写屏障



应用写屏障后，JVM会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行了更新，就会产生额外的开销。但这个开销与扫描老年代的代价相比非常低。



卡表在高并发场景下 还面临着伪共享的问题。现代中央处理器的缓存系统中是以缓存行为单位存储的，当多线程修改相互独立的变量时，如果这些变量恰好共享一个缓存行，为了并发安全，会有一些策略如同步，就会彼此影响而导致性能降低。

为了避免伪共享问题，一个简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有未被标价过才将其标记为变脏

```c
if(CARD_TABLE[this address >> 9] != 1) {
	CARD_TABLE[this address >> 9] = 1;
}
```

JDK7后，HotSpot增加了一个新的参数 -XX:+UseCondCardMark，用来决定是否开启卡表更新的条件判断。
