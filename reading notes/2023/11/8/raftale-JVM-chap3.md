# 经典垃圾收集器

1. Serial收集器：新生代垃圾回收时暂停所有用户线程，然后单线程完成垃圾收集

1. 1. Serial：新生代采用复制算法，暂停所有用户线程
2. Serial Old：老年代采用标记-整理算法，暂停所有用户线程

1. ParNew收集器：Serial收集器的多线程版本，在多处理器环境中性能比Serial好

1. 1. 垃圾回收算法与Serial一致

1. Parallel Scavenge收集器：新生代收集器，不关注停顿时间，目标是达到一个可控制的吞吐量

1. 1. 吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）
2. 该收集器下，停顿时间与吞吐量是矛盾的，停顿时间短是牺牲了吞吐量和新生代空间：系统把新生代调小一些，垃圾回收会变快，但频率也会变高，就影响了吞吐量。
3. Parallel Old：老年代版本





## CMS

Concurrent Mark Sweep：并发标记-清除

目标：最短回收停顿时间

过程：

1. 初始标记：标记一下GC Roots能直接关联到的对象

1. 1. 存在STW，

1. 并发标记：从GC Roots的值开始遍历整个对象图的过程，耗时较长但不需要停止用户线程
2. 重新标记：修正并发标记期间因为用户线程修改对象关系导致的漏标问题，解决方法是增量更新。

1. 1. 存在STW，但初始标记阶段稍微长一点，但比并发标记时间短

1. 并发清除：清除掉已经判定为死亡的对象，因为是并发-清除算法，所以不需要STW



缺点：

1. 对处理器资源非常敏感
2. 无法处理「浮动垃圾」
3. 空间碎片化

## Garage First

简称G1.

创新点在于 面向局部收集的设计思路 和 基于Region的内存布局方式。

目标：在延迟可控的情况下尽可能获得较高的吞吐量



G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，其比例不再是固定的。收集器能够对不同角色的Region采用不同的策略去处理。

G1每次回收都是Region大小的整数倍，这可以有计划的避免进行全区域的垃圾收集。通过收集各个Region里面的垃圾堆积的价值大小，即回收所需要的空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（-XX:MaxGCPauseMills，默认200ms）优先处理回收价值收益最大的Region。这也是Garage First名字的来源。



新的模型如何解决固有的问题：

1. 找GC Roots时，跨Region引用如何解决？

1. 1. 每个Region都维护自己的记忆集，每个记忆集会记录下别动Region指向自己的指针，并标记这些指针分别在哪些卡页的范围内。

1. 如何解决漏标问题？

1. 1. 原始快照（SATB）：

1. 如何建立可靠的停顿预测模型？

1. 1. 统计



大致步骤：

1. 初始标记：标记一下GC Roots能直接关联到的对象

1. 1. 借用进行Minor GC的时候同步完成的，没有额外的停顿

1. 并发标记：从GC Roots进行可达性分析
2. 最终标记：需要暂停用户线程，解决漏标问题，再次进行标记
3. 筛选回收：

1. 1. 更新Region的统计数据
2. 对Region对回收价值和成本进行排序
3. 根据用户所期望的停顿时间制定回收计划，可自由选择任意多个Region构成回收集。
4. 回收中存活的对象复制到空的Region中，再清理掉旧Region的全部空间。
5. 过程中需要暂停用户线程



G1的停顿时间一般为上百毫秒，如果设置的太小，可能导致收集器收集的速度跟不上分配的速度，最终导致Full GC。

G1的创新思想是：不追求一次把堆都全部清理干净，而是保证收集的速度能跟上对象分配的速度，保证能长期运行。

G1中将存活的对象复制到空的Region使用的复制算法，整体上是标记-整理算法，不会产生内存碎片。



局限：

1. G1的内存比CMS高
2. G1的负载比CMS高
