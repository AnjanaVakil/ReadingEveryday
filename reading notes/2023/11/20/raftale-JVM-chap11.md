# 即时编译器

即时编译器：Just In time, JIT。在运行时把字节码转变为本地机器码的过程。

最开始Java程序都是通过解释器进行解释执行的。当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为热点代码（Hot Spot Code），为了提高热点代码的执行效率，运行时，虚拟机会把这些代码编译成本地机器码，并以各种手段尽可能的进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。

## 解释器与编译器

解释器：解释执行，运行时把字节码转变为本地机器码

编译器：热点代码编译成本地机器码，避免解释执行的开销

解释器与编译器相辅相成的配合工作，如果编译器对热点代码根据概率选择的编译本地机器码不再适用于加载新类后的情况，可以通过逆优化回退到解释器执行，等到合适的机会再提前编译。



## 编译对象与触发条件

热点代码主要有两类：

1. 被多次执行的方法
2. 被多次执行的循环体



热点探测的手段：

1. 基于采样的热点探测：周期性的检查各个线程的调用栈顶
2. 基于计数器的热点探测：给每个方法建立计数器，超过阈值就认为是热点

## 编译过程



# 提前编译器

## 提前编译的优劣得失

即时编译的最大弱点：要占用程序运行时间和运算资源。

即时编译相对应提前编译的天然优势：

1. 性能分析制导优化：监控 统计预测
2. 激进预测性优化：按照高概率的假设进行优化，大不了回退到解释器上重新执行
3. 链接时优化：一个class文件在运行期被加载到虚拟机内存中，然后在即时编译器里产生优化后的本地代码。





# 编译器优化技术





```java
static class B {
    int value;
    final int get() {
        return value;
    }
}

public void foo() {
    y = b.get();
    z = b.get();
    sum = y + z;
}
```

内联后的代码：

1. 去除方法调用的成本；
2. 为其他优化建立良好的基础

```java
public void foo() {
    y = b.value;
    z = b.balue;
    sum = y + z;
}
```



## 方法内联

之前说到，虚方法内联因为多态性很难确定使用哪个方法版本，为了解决虚方法的内联问题，JVM引入了一种名为类型继承关系分析（Class Hierarchy Analysis, CHA）的技术。这是整个应用程序范围内的类型分析技术，用于确定在目前已经加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。

CHA并不是完全准确的，因为Java是动态连接的，可能因为加载新的类型导致CHA的结论失效，所以这是一种激进预测性优化。

## 逃逸分析

逃逸分析的基本原理是：分析对象动态作用域。

1. 方法逃逸：一个对象在方法里面被定义后，它可能被外部方法所引用
2. 线程逃逸：实例变量被外部线程访问到
3. 从不逃逸

如果能证明一个对象不会逃逸到方法或者线程之外，则可能为这个对象实例采取不同程度的优化：

1. 栈上分配：如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将能够使得对象占用空间随着栈帧出栈而销毁。

1. 1. 支持方法逃逸，但不能支持线程逃逸

1. 标量替换：标量就是原始数据类型，不可再拆解了。如果一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行时就可以不去创建这个对象，而是改为直接创建它的若干被这个方法使用的成员变量来替代。

1. 1. 栈上分配的一种特例。不允许对象逃逸出方法范围内

1. 同步消除（Synchronization Elimination）：如果一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的同步开销就可以消除掉。



```java
// 完全未优化的代码
public int test(int x) {
	int xx = x + 2;
	Point p = new Point(xx, 42); 
	return p.getX();
}
```



```java
// 步骤1:构造函数内联后的样子 
public int test(int x) { 
	int xx = x + 2;
	Point p = point_memory_alloc(); // 在堆中分配P对象的示意方法
	p.x = xx;		// Point构造函数被内联后的样子
	p.y = 42  		// Point::getX()被内联后的样子
	return p.x;
 

}
```

逃逸分析后进行标量替换：

```java
// 步骤2:标量替换后的样子 
public int test(int x) {
	int xx = x + 2; 
	int px = xx; 
	int py = 42;
	return px;
}
```

无效代码消除：

```java
// 步骤3:做无效代码消除后的样子
public int test(int x) {
	return x + 2; 
}
```

## 公共子表达式消除


## 数组边界检查消除
