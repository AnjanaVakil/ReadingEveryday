# 实战：内存分配与回收策略



自动内存管理系统，最核心的目标是：自动给对象分配内存，以及自动回收分配给对象的内存。

接下来验证Serial和Serial Old的分配回收策略，

1. Serial：新生代采用复制算法
2. Serial Old：老年代采用标记-整理算法

分代：90%新生代（80%的Eden + 10%的Survivor）， 老年代（10%的Survivor ）

分配内存时先分配到Eden和其中一个Survivor，垃圾收集时，将Eden和Survivor中存活的对象一次性复制到另外一块Survivor

## 对象优先在Eden分配

对象在Eden分配，当Eden区没有足够空间进行分配时，JVM将发起一次Minor GC。



## 大对象直接进入老年代

+XX:PretenureSizeThreshold设置，指定大于改设置值的对象直接在老年代分配。



## 长期存活的对象将进入老年代

JVM给每一个对象定义了一个对象年龄计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次MInorGC仍然存活，并且能够被Survivor容纳的话，就会分配到Survivor空间中。对象在Survivor没熬过一次Minor GC，年龄就增加一岁，当它的年龄增加到一个阈值后，就会被晋升到老年代中。阈值由-XX:MaxTenuringThreshold设置，默认15.

## 动态对象年龄判断

为了更好的适应不同程序的内存状况，HotSpot并不是永远要求对象的年龄必须达到阈值才能晋升老年代，如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。

## 空间分配担保

在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果成立，那这一次Minor GC可以确保是安全的，否则虚拟机会先查看-XX:handlePromotionFailure参数的设置值是否允许担保失败。

允许担保失败时，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试一次Minor GC；如果小于，那就要进行一次Full GC。
