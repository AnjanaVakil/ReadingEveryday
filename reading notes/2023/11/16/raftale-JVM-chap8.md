# 运行时栈帧结构

虚拟机栈中提到过栈帧，存储了方法的局部变量表、操作数栈、动态链接、方法返回地址等信息。


## 局部变量表

局部变量表是一组变量值的存储空间，存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽（slot）为最小单位。


## 操作数栈

虚拟机栈是方法的入栈和出栈，操作数栈则是方法中各个语句的入栈和出栈。当一个方法开始执行的时候，这个方法的操作数栈是空的，再执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容。

## 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

Class文件的常量池中存有大量的符号引用。每一次在运行时转化为直接引用的

## 方法返回地址

方法退出有两种方式：

1. 正常调用完成
2. 异常调用完成

方法退出的过程实际上等同于把当前栈帧出栈，因此退出可能的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中等。

# 方法调用

方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。

第7章讲过，Class文件的编译过程不包含传统程序语言编译的链接步骤，一切方法调用在class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（即直接引用）。

这个特效给Java带来了更强大的动态扩展能力，但也是方法调用过程变得相对复杂。

## 解析

类加载的解析阶段，会将一部分符号引用转化为直接引用。

这部分能在解析阶段就转化的原因是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，方法调用在编译那一刻就确定下来了，这类方法的调用被称为解析（resolution）。

这类方法有两大类：静态方法和私有方法。静态方法与类型直接关联，私有方法不可被外部访问。

调用不同类型的方法，字节码指令集设计了不同的指令。JVM中支持以下5条方法调用字节码指令，分别是：

1. invokestatic：调用静态方法
2. invokespecial：调用实例构造器<init>()方法、私有方法和父类中的方法
3. invokevirtual：调用所有的虚方法
4. invokeinterface：调用接口方法，会在运行时再确定一个实现该接口的对象
5. invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。



非虚方法：在类加载的时候就可以把符号引用解析为该方法的直接引用

1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法
5. 被final修饰的方法：由于历史设计，使用的是invokevirtual

其余的方法都被称为「虚方法」

## 分派

另一种调用方式是分派（dispatch），分派复杂许多。

### 静态分派

所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段。

```java
Human human = new Man();
// Human是静态类型， Man是运行时类型或者实际类型
```

静态方法会在编译器确定、在类加载期就进行解析，但静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。
