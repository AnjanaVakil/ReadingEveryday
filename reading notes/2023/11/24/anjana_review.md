动态代理两种方式的区别：

ChatGPT

在Java中，有两种主要的方式来实现动态代理：

* 基于接口的动态代理（JDK动态代理）
* 基于类的动态代理（CGLIB动态代理）

这两种方式有一些显著的区别：

### 1. **基于接口的动态代理（JDK动态代理）:**

- **原理：** JDK动态代理是通过`java.lang.reflect.Proxy`类和`InvocationHandler`接口实现的。它要求目标类必须实现一个接口，代理对象也会实现这个接口，代理对象的方法调用会委托给`InvocationHandler`的`invoke`方法来处理。
- **限制：** JDK动态代理要求目标类必须实现接口，这是其一个限制。如果目标类没有实现接口，就无法使用JDK动态代理。
- **创建代理对象：** 使用`Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`方法创建代理对象，需要传入类加载器、实现的接口数组和`InvocationHandler`实现类的实例。

### 2. **基于类的动态代理（CGLIB动态代理）:**

- **原理：** CGLIB（Code Generation Library）动态代理是通过创建目标类的子类来实现的。它不要求目标类实现接口，通过继承的方式实现代理。CGLIB在运行时动态生成目标类的子类，并覆盖其中的方法以实现代理逻辑。
- **适用性：** CGLIB适用于对类的代理，而不仅仅是接口。它可以代理没有实现接口的类。
- **创建代理对象：** 使用`Enhancer`类来创建代理对象，需要设置目标类的类和`MethodInterceptor`实现类的实例。

### 3. **性能差异：**

- **性能：** 一般情况下，基于接口的动态代理相对来说更轻量级，性能更好。CGLIB动态代理生成的代理类继承自目标类，因此调用代理方法的性能会受到继承性能的影响。但在实际情况中，性能差异可能并不显著，具体性能取决于使用的场景和具体的实现。

### 4. **使用场景：**

- **JDK动态代理：** 适用于要求代理对象实现接口的场景，比如Spring AOP。
- **CGLIB动态代理：** 适用于对类进行代理的场景，尤其是目标类没有实现接口的情况。

总的来说，选择使用JDK动态代理还是CGLIB动态代理，取决于具体的需求和场景。在Spring AOP中，如果目标类实现了接口，则使用JDK动态代理；如果目标类没有实现接口，则使用CGLIB动态代理。 Spring AOP会根据情况选择合适的代理方式。