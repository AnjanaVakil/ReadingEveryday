## Basic Asm
1. 基本语法：`asm asm-qualifiers ( AssemblerInstructions )`。这里的 `asm` 关键字在 C 语言中是 GNU 的扩展。在没有 GNU 扩展的 C 方言中，需要使用 `__asm__` 代替 `asm`。对于 C++ 语言，`asm` 是标准关键字，但如果编译时使用 `-fno-asm` 选项，也可以使用 `__asm__`。

2. 修饰符：介绍了 `volatile` 和 `inline` 两种修饰符。`volatile` 修饰符是可选的，没有效果，因为所有的基本 asm 块都被隐式视为 volatile。如果使用 `inline` 修饰符，那么在内联时，asm 语句的大小将被认为是尽可能小的。

3. 参数：`AssemblerInstructions` 是指定汇编代码的字符串。这个字符串可以包含汇编器识别的任何指令，包括指令。GCC 不解析汇编指令本身，也不知道它们的含义，甚至不知道它们是否是有效的汇编输入。

4. 注意事项：比起基本的 asm，扩展的 asm (extended asm) 通常会产生更小、更安全、效率更高的代码，大多数情况下它是更好的选择。但在以下两种情况中，只能使用基本的 asm： 
    - 扩展 asm 语句必须在 C 函数内，因此，如果想在文件范围（“顶级”）的外部编写内联汇编语言，必须使用基本 asm。
    - 使用 naked 属性声明的函数也需要基本 asm。

5. GCC 不解析基本 asm 的 AssemblerInstructions，这意味着编译器无法了解其内部的活动。它不知道 asm 中的符号，并可能将其视为未引用而丢弃。它也不了解汇编代码的副作用，例如对内存或寄存器的修改。

6. 由于未来可能对语义的更改和编译器之间的兼容性问题，建议考虑将基本 asm 替换为扩展 asm。

7. 举例：给出了 i386 的基本 asm 示例。
```
/* Note that this code will not compile with -masm=intel */
#define DebugBreak() asm("int $3")
```

## Convert Basic asm to Extended asm
上述文本主要讨论了如何将基本汇编（basic asm）转换为扩展汇编（extended asm），以及为什么进行这样的转换。以下是主要内容的概述：

1. **为什么转换**：扩展汇编允许程序员为汇编指定输入、输出以及它修改了哪些寄存器（破坏），而基本汇编则不能。不同的 C 编译器在汇编代码可以覆盖哪些寄存器方面有不同的语义。gcc 假定没有寄存器被修改。如果你的汇编修改了寄存器而没有告知编译器（这需要使用扩展汇编），将导致未定义的行为。

2. **如何转换（简短版）**：转换的步骤相当直接。简要来说，你需要在你的基本汇编语句的字符串后加上 ":"。如果你的基本汇编字符串包含 '%' 字符，需要使用 '%%' 对它们进行转义。

3. **如何转换（详细版）**：可以通过在末尾添加 ":" 来将基本内联汇编语句转换为扩展汇编语句。如果你的基本汇编字符串包含 '%' 字符，你需要使用 '%%' 进行转义。支持方言的平台（包括 i386, pa, pdp11, rs6000, sh）上，'{' '|' 和 '}' 字符都有特殊含义，它们需要使用 '%{'，'%|' 或 '%}' 进行转义。

4. **转换不正确的代码**：对于编写不正确的汇编（这很容易做到），你可能需要做更多的工作。例如，考虑这段 MIPS 代码：`asm ("sync");` 在一个为汇编语句破坏内存的编译器中，这将正确工作。然而，由于 gcc 的基本汇编不破坏内存，它需要写成这样：`asm ("sync" : : : "memory");`

5. **特殊情况**：在一些特殊情况下，转换可能需要更复杂的处理，如在 i386 平台上，扩展汇编总是破坏标志，无论是否指定了 "cc"。

这段文本也提到，尽管内联汇编（inline asm）具有强大的功能，但其维护性差，非可移植性，并且实际上可能比使用 C 语言慢。因此，如果你打算修改你的内联汇编，你可能需要考虑不使用内联汇编。