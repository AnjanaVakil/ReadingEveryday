`type-switch`流程控制代码块

-   看作是类型断言的增强版
-   一个`type-switch`代码块可以不包含任何分支，它可以被视为一个空操作
-   不能使用`fallthrough`



接口值相关的比较

-   比较一个非接口值和接口值
    -   非接口值的类型必须实现了接口值的类型，非接口值可以被隐式转化。
    -   非接口值和接口值的比较可以转化为两个接口值的比较
-   比较两个接口值
    -   比较这两个接口值的动态类型和和动态值
    -   一个接口值是一个`nil`接口值，则比较结果为另一个接口值是否也为一个`nil`接口值
    -   两个接口值的动态类型不一样，则比较结果为false
    -   两个接口值的动态类型一样
        -   动态类型为一个不可比较类型，则产生恐慌
        -   否则，比较结果为它们的动态值的比较结果



接口值的内部结构

-   空接口值和非空接口值是使用两种内部结构



指针动态值和非指针动态值

-   标准编译器/运行时对接口值的动态值为指针类型的情况做了优化
-   尽量避免在接口值中包裹大尺寸值。对于大尺寸值，应该尽量包裹它的指针



一个`[]T`类型的值不能直接被转换为类型`[]I`，即使类型`T`实现了接口类型`I`

-   如，不能直接将一个`[]string`值转换为类型`[]interface{}`
-   必须使用循环来实现此转换



一个接口类型每个指定的每一个方法都对应着一个隐式声明的函数

-   接口类型`I`指定了名为`m`的方法，则编译器将隐式声明一个与之对应的函数名为`I.m`的函数
-   此函数比`m`的方法描述中的参数多一个
-   多出来的参数为函数`I.m`的第一个参数，它的类型为`I`
-   对于一个类型为`I`的值`i`，方法调用`i.m(...)`和函数调用`I.m(i, ...)`是等价的



Pp. 243-248