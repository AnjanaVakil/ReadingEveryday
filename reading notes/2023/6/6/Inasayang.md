遍历容器元素

```
for key, element = range aContainer { 
   // 使用key和element ... 
} 
```

-   如果`aContainer`是一个切片或者数组（或者数组指针），则`key`的类型必须为内置类型`int`
-   遍历一个`nil`映射或者`nil`切片是允许的。这样的遍历可以看作是一个空操作
    -   遍历映射条目的细节
        -   映射中的条目的遍历顺序是不确定的
        -   在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来
        -   在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来
-   被遍历的容器值是`aContainer`的一个副本，只是复制了`aContainer`的直接部分。
    -   如果`aContainer`是一个数组，那么在遍历过程中对此数组元素的修改不会体现到循环变量中。 原因是此数组的副本（被真正遍历的容器）和此数组不共享任何元素
    -   如果`aContainer`是一个切片（或者映射），那么在遍历过程中对此切片（或者映射）元素的修改将体现到循环变量中。 原因是此切片（或者映射）的副本和此切片（或者映射）共享元素（或条目）
-   复制一个切片或者映射的代价很小，但是复制一个大尺寸的数组的代价比较大



把数组指针当做数组来使用

-   复制一个指针比复制一个大尺寸数组的代价低得多

```
for i, n := range &a {// 复制一个指针的开销很小
for i, n := range a[:] { // 复制一个切片的开销很小
```

-   如果一个`for-range`循环中的第二个循环变量既没有被忽略，也没有被舍弃，并且`range`关键字后跟随一个`nil`数组指针，则此循环将造成一个恐慌
-   从一个`nil`数组指针派生切片将导致一个恐慌
-   内置`len`和`cap`函数调用接受数组指针做为实参， `nil`数组指针实参不会导致恐慌





`memclr`优化

-   t0是一个类型T的零值字面量，并且a是一个元素类型为T的数组或者切片
-   把单循环变量`for-range`代码块优化为一个内部的`memclr`调用
-   大多数情况下，此`memclr`调用比一个一个地重置元素要快

```
1| for i := range a {
2|	a[i] = t0
3| }
```





切片克隆

```
sClone := append(s[:0:0], s...) 
```

```
sClone := append([]T(nil), s...) 
```

和上面这个实现相比，它有一个不完美之处：如果源切片`s`是一个空切片（但是非`nil`），则结果切片是一个`nil`切片。

两种`append`实现都有一个缺点：它们开辟的内存块常常会比需要的略大一些从而可能造成一点小小的不必要的性能损失



两种方法来避免这个缺点

```
// 两行make+copy实现： 
sClone := make([]T, len(s)) 
copy(sClone, s) 
```

```
// 或者下面的make+append实现。 
// 对于目前的官方Go工具链v1.20来说，这种 
// 实现比上面的make+copy实现略慢一点。 
sClone := append(make([]T, 0, len(s)), s...) 
```

上面这两种`make`方法都有一个缺点：如果`s`是一个`nil`切片，则使用此方法将得到一个非`nil`切片



Pp. 167-181