结构体

-   一个结构体类型的尺寸为它的所有字段的（类型）尺寸之和加上一些填充字节的数目
-   常常地，编译器（和运行时）会在一个结构体值的两个相邻字段之间填充一些字节来保证一些字段的地址总是某个整数的倍数
-   一个零字段结构体的尺寸为零
-   如果一个结构体值是可寻址的，则它的字段也是可寻址的；反之，一个不可寻址的结构体值的字段也是不可寻址的



Go类型分为两大类别（category）

-   在C中，值的内存结构都是很透明的；但在Go中，对于某些类型的值，其内存结构却不是很透明
-   在C中，每个值在内存中只占据一个内存块（一段连续内存）；但是，一些Go类型的值可能占据多个内存块
-   一个Go值分布在不同内存块上的部分为此值的各个值部（`value part`）
-   一个分布在多个内存块上的值含有一个直接值部和若干被此直接值部引用着的间接值部

| 每个值在内存中只分布在一个内存块上的类型                     | 每个值在内存中会分布在多个内存块上的类型                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单直接值部                                                   | 直接值部-> 底层间接值部                                      |
| 布尔类型<br/>各种数值类型<br/>指针类型<br/>非类型安全指针类型<br/>结构体类型<br />数组类型 | 切片类型<br/>映射类型<br/>通道类型<br/>函数类型<br/>接口类型<br/>字符串类型 |



Go中的两种指针类型

-   非类型安全的指针类型提供在`unsafe`标准库包中
-   非类型安全指针类型通常使用`unsafe.Pointer`来表示。 `unsafe.Pointer`类似于C语言中的`void*`
-   一个指针值存储着另一个值的地址，除非此指针值是一个`nil`空指针
-   将一个含有（直接或者间接）指针字段的结构体类型称为一个指针包裹类型
-   将一个含有（直接或者间接）指针的类型称为指针持有者类型
-   指针类型和指针包裹类型都属于指针持有者类型
-   元素类型为指针持有者类型的数组类型也是指针持有者类型



映射、通道和函数类型的内部定义

```
1| // 映射类型
2| type _map *hashtableImpl // 目前，官方标准编译器是使用
3| // 哈希表来实现映射的。
4|
5| // 通道类型
6| type _channel *channelImpl
7|
8| // 函数类型
9| type _function *functionImpl
```

-   这三个种类的类型的内部结构其实是一个指针类型
-   这些类型的值的直接部分在内部是一个指针
-   这些类型的值的直接部分在内部是一个指针



```
1| type _slice struct {
2|	elements unsafe.Pointer // 引用着底层的元素
3|	len int // 当前的元素个数
4|	cap int // 切片的容量
5| }
```

-   一个切片类型在内部可以看作是一个指针包裹类型
-   每个非零切片值包含着一个底层间接部分用来存储此切片的元素
-   一个切片值的底层元素序列（间接部分）被此切片值的`elements`字段所引用



```
1| type _string struct {
2|	elements *byte // 引用着底层的byte元素
3|	len int // 字符串的长度
4| }
```

-   每个字符串类型在内部也可以看作是一个指针包裹类型
-   每个非零字符串值含有一个指针字段 `elements`
-   指针字段引用着此字符串值的底层字节元素序列



空接口类型（空接口类型没有指定任何方法）

```
1| type _interface struct {
2|	dynamicType *_type // 引用着接口值的动态类型
3|	dynamicValue unsafe.Pointer // 引用着接口值的动态值
4| }
```

-   接口类型也可以看作是一个指针包裹类型
-   一个接口类型含有两个指针字段
-   每个非零接口值的（两个）间接部分分别存储着此接口值的动态类型和动态值
-   两个间接部分被此接口值的直接字段`dynamicType`和`dynamicValue`所引用



非空接口类型

```
1| type _interface struct {
2|	dynamicTypeInfo *struct {
3|	dynamicType *_type // 引用着接口值的动态类型
4|	methods []*_function // 引用着动态类型的对应方法列表
5| }
6| dynamicValue unsafe.Pointer // 引用着动态值
7| }
```

-   一个非空接口类型的值的`dynamicTypeInfo`字段的`methods`字段引用着一个方法列表
-   列表中的每一项为此接口值的动态类型上定义的一个方法



在赋值中，底层间接值部将不会被复制

-   每个赋值操作（包括函数调用传参等）都是一个值的浅复制过程（假设源值和目标值的类型相同）
-   在一个赋值操作中，只有源值的直接部分被复制给了目标值。 如果源值含有间接部分，则在此赋值操作完成之后，目标值和源值的直接部分将引用着相同的间接部分（两个值将共享底层的间接值部）
-   一个间接值部可能并不专属于任何一个值，所以在使用`unsafe.Sizeof`函数计算一个值的尺寸的时候，此值的间接部分所占内存空间未被计算在内



关于术语“引用类型”和“引用值”

-   只有切片、映射、通道和函数类型属于引用类型
-   一些函数调用的参数是通过引用来传递的（所有的函数调用的参数都是通过值复制直接值部的方式来传递的）



Pp. 127-141