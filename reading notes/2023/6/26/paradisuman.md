
| 锁的作用 | 描述 |
| --- | --- |
| 防止资源竞争 | 结合p->state, p->lock 防止在为新进程分配proc[]槽位时出现竞争。 |
| 进程隔离 | 当进程正在创建或销毁时，p->lock将其从视图中隐藏。 |
| 防止过早回收 | 它阻止父进程的wait过早收集已经将其状态设置为ZOMBIE但尚未放弃CPU的进程。 |
| 防止抢占调度 | 防止另一个内核的调度程序在进程将其状态设置为RUNNABLE但在完成swtch之前决定运行它。 |
| 单一调度 | 确保只有一个内核的调度器决定运行RUNNABLE进程。 |
| 防止中断干扰 | 防止定时器中断在进程在swtch中时引起进程yield。 |
| 同步唤醒 | 结合条件锁，帮助防止wakeup忽视正在调用sleep但尚未完成放弃CPU的进程。 |
| 保护受害进程 | 防止在kill检查p->pid和设置p->killed之间，受害进程退出并可能被重新分配。 |
| 保证原子性 | 使kill的检查和对p->state的写入成为原子操作。 |

注意：p->parent字段由全局锁wait_lock而不是p->lock保护。只有进程的父进程修改p->parent，尽管进程本身和其他寻找子进程的进程都会读取该字段。wait_lock的目的是在wait睡眠等待任何子进程退出时充当条件锁。一个正在退出的子进程在设置其状态为ZOMBIE，唤醒其父进程并放弃CPU后，会持有wait_lock或p->lock。wait_lock还通过序列化父进程和子进程的并发退出，确保init进程（继承了子进程）被唤醒出它的wait。wait_lock是全局锁而不是每个父进程中的每个进程锁，因为在进程获取它之前，它无法知道谁是它的父进程。