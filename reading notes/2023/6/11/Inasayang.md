

方法描述（`method specification`）和方法集（`method set`）

-   方法描述是一个不带`func`关键字的函数原型
-   方法声明由一个`func`关键字、一个属主参数声明部分、一个方法描述和一个方法体组成
-   类型T的方法集总是类型*T的方法集的子集
-   不同代码包中的同名非导出方法将总被认为是不同名的
-   下列类型的方法集总为空
    -   内置基本类型
    -   定义的指针类型
    -   基类型为指针类型或者接口类型的指针类型
    -   无名数组/切片/映射/函数/通道类型



方法值的正规化

-   正规化是将方法值表达式中的隐式取地址和解引用操作均转换为显式操作
-   假设值`v`的类型为`T`，并且`v.m`是一个合法的方法值表达式
    -   `m`是类型`*T`显式声明的方法，编译器会正规化`(&v).m`
    -   `m`是类型`T`显式声明的方法，则不需要正规化
-   假设值`p`的类型为`*T`，并且`p.m`是一个合法的方法值表达式
    -   `m`是类型`T`显式声明的方法，编译器会正规化`(*p).m`
    -   `m`是类型`*T`显式声明的方法，则不需要正规化



方法值的估值

-   `v.m`是一个正规化的方法值表达式，在运行时刻，当`v.m`被估值的时候，属主实参v的估值结果的一个副本将被存储下来以供后面调用此方法值的时候使用
-   `v`的类型为`T`，则是复制值
-   `v`的类型为`*T`，则是复制地址





一个定义类型不会获取为它的源类型显式声明的方法

```
1| package main
2|
3| type MyInt int
4| func (mi MyInt) IsOdd() bool {
5| 	return mi%2 == 1
6| }
7|
8| type Age MyInt
9|
10| func main() {
11| var x MyInt = 3
12| _ = x.IsOdd() // okay
13| 
14| var y Age = 36
15| // _ = y.IsOdd() // error: y.IsOdd undefined
16| _ = y
17| }
```





如何决定一个方法声明使用值类型属主还是指针类型属主？

-   总可以在方法声明中使用指针类型属主而不会产生任何逻辑问题

-   为了程序效率考虑有时候才会在函数声明中使用值类型属主

-   一些考虑因素

    -   太多的指针可能会增加垃圾回收器的负担
    -   如果值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型
    -   在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争
    -   `sync`标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法

    

Pp. 222-230