恐慌（`panic`）和恢复（`recover`）

-   调用内置函数`panic`来产生一个恐慌以使当前协程进入恐慌状况

-   进入恐慌状况是另一种使当前函数调用开始返回的途径。 一旦一个函数调用产生一个恐慌，此函数调用将立即进入它的退出阶段。

-   在一个延迟函数调用之中调用内置函数`recover`，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况。

-   如果一个协程在恐慌状况下退出，它将使整个程序崩溃。

-   一个`recover`函数的返回值为其所恢复的恐慌在产生时被一个`panic`函数调用所消费的参数。

-   一些致命性错误不属于恐慌（比如栈溢出和内存不足）

    

```go
1|package main
2|
3|import "fmt"
4|
5|func main() {
6|	defer func() {
7|		fmt.Println("正常退出")
8|	}()
9|	fmt.Println("嗨！")
10| defer func() {
11|		v := recover()
12| 	fmt.Println("恐慌被恢复了：", v)
13| }()
14| panic("拜拜！") // 产生一个恐慌
15| fmt.Println("执行不到这里")
16|}
```

```
嗨！
恐慌被恢复了： 拜拜！
正常退出
```



Go类型系统

类型的种类

-   基本类型和组合类型都对应着一个类型种类（`kind`）
-   非类型安全指针类型属于另外一个新的类型种类
-   Go有26个类型种类



类型定义（`type definition declaration`）

-   类型定义又称类型定义声明
-   每个类型描述创建了一个全新的定义类型（`defined type`）
-   一个新定义的类型和它的源类型为两个不同的类型
-   在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型
-   一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。
-   类型定义可以出现在函数体内



自定义泛型类型和实例化类型（`generic type and instantiated types`）

-   一个泛型类型必须被实例化才能被用做值类型。
-   自定义泛型的两个重要的概念：类型约束（`constarint`）和类型参数（`typeparameter`）



类型别名声明（`type alias declaration`）

-   可以被声明在函数体内



底层类型（`underlying type`）

-   每个类型都有一个底层类型
-   一个内置类型的底层类型为它自己
-   `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己
-   一个无名类型（必为一个组合类型）的底层类型为它自己
-   在一个类型声明中，新声明的类型和源类型共享底层类型



指针类型的基类型（`base type`）

-   如果一个指针类型的底层类型表示为*T，则此指针类型的基类型为T所表示的类型



接口类型的动态类型和动态值

-   接口类型的值称为接口值
-   一个接口值可以包裹装载一个非接口值
-   包裹在一个接口值中的非接口值称为此接口值的动态值
-   此动态值的类型称为此接口值的动态类型
-   一个什么也没包裹的接口值为一个零值接口值
-   零值接口值的动态值和动态类型均为不存在



可比较类型和不可比较类型

-   切片类型
-   映射类型
-   函数类型
-   任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型
-   其它类型称为可比较类型
-   映射类型的键值类型必须为可比较类型



Pp. 105-118