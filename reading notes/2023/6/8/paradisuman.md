
| 标题             | 描述                                                                                          |
|----------------|-------------------------------------------------------------------------------------------|
| 竞态条件     | 当一个内存位置被并发地访问，且至少有一个访问是写操作时，就会发生竞态条件。竞态条件通常是一个错误的标志。如果两个写操作同时进行，可能会出现“丢失更新”的问题。读取未完全更新的数据结构也可能引发问题。        |
| 锁              | 锁用于保证互斥，这样在执行敏感代码时，一次只能有一个CPU操作。例如，在上述的代码中，有一个push函数，当有两个CPU同时执行这个函数时，就可能出现问题。使用锁可以避免这种情况。    |
| 临界区       | 获取锁和释放锁之间的指令序列通常被称为临界区。锁被认为是保护临界区内的数据。                                                                      |
| 不变性         | 当我们说锁保护数据时，我们实际上是说锁保护了适用于数据的一组不变性。不变性是跨操作保持的数据结构属性。一个操作的正确行为通常依赖于操作开始时不变性为真。操作可能会暂时违反不变性，但必须在完成前重新建立它们。 |
| 锁定的性能问题 | 尽管正确使用锁可以使错误的代码正确，但锁会限制性能。如果多个进程同时调用kfree，锁将使两个调用序列化，并且我们无法从在不同的CPU上运行它们中获益。因此，内核设计的一个主要挑战是避免锁冲突。           |
| 锁的位置      | 锁的位置对于性能也非常重要。例如，在push函数中，提前获取锁是正确的，但是这可能会降低性能，因为这样就序列化了对malloc的调用。关于在何处插入获取和释放锁的调用，以下“使用锁”部分提供了一些指导原则。     |
