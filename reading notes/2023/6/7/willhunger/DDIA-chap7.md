#### 2. Two-Phase Locking
两阶段加锁，锁的强制性更高，多个事务可以同时读取同一对象，但只要出现任何写操作（包括修改或删除），则必须加锁以单独访问：
* 如果事务 A 已经读取了某个对象，此时事务 B 想要写入该对象，那么 B 必须等到 A 提交或中止后才能继续，以确保 B 不会再事务 A 执行过程中去修改对象。
* 如果事务 A 已经修改了对象，此时事务 B 想要读取该对象，则 B 必须等到 A 提交或者中止以后才能继续。对于 2PL，不会出现读到旧值的情况。

##### Implementation of two-phase locking
2PL 用于实现 MySQL(InnoDB) 和 SQL Server 中的 "可串行化隔离"，以及 DB2 中的 "可重复读隔离"。

数据库的每个对象都有一个读写锁来隔离读写操作。 即锁可以处千共享模式或独占模式。用法如下：
* 如果事务要读取对象，必须先以共享模式获得锁。可以有多个事务同时获得一个对象的共享锁。但如果某个事务已经获得了该对象的独占锁，则所有其它事务必须等待。
* 如果事务要修改对象， 必须以独占模式获取锁。 不允许多个事务同时持有该锁。
* 如果事务首先读取对象， 然后尝试写入对象， 则需要将共享锁升级为独占锁。 升级锁的流程等价于直接获得独占锁。
* 事务获得锁以后，一直持续锁直到所有事务结束。

使用锁机制，很容易出现死锁，此时强制中止其中一个事务即可。

##### Performance of two-phase locking
2PL 的事务吞吐量和查询响应时间相比于其他弱隔离级别下降非常多。

原因：锁争用的开销，降低了事务的并发性。导致了 2PL 模式下数据访问延迟的不确定性，死锁发生比读已提交更频繁。如果事务由于死锁被打断中止，应用层就必须从头重试，导致性能进一步降低。

##### Predicate locks
谓词锁作用于满足某些搜索条件的所有查询对象，例如：
```sql
SELECT * FROM bookings 
	WHERE room_id = 123 AND
		end_time > '2018-01-01 12:00' AND 
		start_time < '2018-01-01 13:00';
```

谓词锁会限制如下访问：
* 如果事务 A 想要读取某些满足搜索条件的对象，其必须以共享模式获得谓词锁，如果事务 B 正持有一个匹配对象的互斥锁，那么 A 必须等到 B 释放后才能继续查询。
* 如果事务 A 想要插入、更新或修改某些对象，则必须检查所有旧值和新值是否与现有的任何谓词锁冲突或匹配。如果事务 B 持有谓词锁，则其必须等待 B 中止或提交后才能继续。

**谓词锁甚至可以保护数据库中那些尚不存在但可能马上会被插入的对象（幻读）**。 将两阶段加锁与谓词锁结合使用， 数据库可以防止所有形式的写倾斜以及其他竞争条件， 隔离变得真正可串行化。

##### Index-range locks
谓词锁性能不佳，检查锁是否匹配耗时太长。因此，大多数使用 2PL 的数据库实际上使用索引区间锁（next-key locking），其本质上是对谓词锁的简化或近似。

简化谓词锁的实现方式：将保护对象扩大化。

直接将锁加在索引上，开销比加在单独对象上低得多。
