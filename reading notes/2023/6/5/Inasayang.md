使用内置`make`函数来创建切片和映射

```
1| make(M, n)
2| make(M)
```

-   第一种调用形式创建了一个可以容纳至少n个条目而无需再次开辟内存的空映射值
-   第二种调用形式创建了一个可以容纳一个小数目的条目而无需再次开辟内存的空映射值。此小数目的值取决于具体编译器实现。
-   注意：第二个参数n可以为负或者零，这时对应的调用将被视为上述第二种调用形式。



```
1| make(S, length, capacity)
2| make(S, length) // <=> make(S, length, length)
```

-   `S`是一个切片类型，`length`和`capacity`是两个非负整数，并且`length`小于等于`capacity`
-   `length`和`capacity`的类型必须均为整数类型（两者可以不一致）
-   使用`make`创建的切片中的所有元素值均被初始化为零值





使用内置`new`函数来创建容器值

-   内置`new`函数可以用来为一个任何类型的值开辟内存并返回一个存储有此值的地址的指针
-   用`new`函数开辟出来的值均为零值
-   `new`函数对于创建映射和切片值来说没有任何价值，但并不是没用（使用组合字面量来创建数组值更为方便）

```
m := *new(map[string]int) // <=> var m map[string]int
fmt.Println(m == nil) // true
s := *new([]int) // <=> var s []int
a := *new([5]bool) // <=> var a [5]bool
fmt.Println(a == [5]bool{}) // true
```





容器元素的可寻址性

-   一个数组是可寻址的，则它的元素也是可寻址的；反之亦然。（数组只含有一个直接值部，并且所有元素和此直接值部均承载在同一个内存块上）
-   一个切片值的任何元素都是可寻址的，即使此切片本身是不可寻址的。（因为切片的底层元素总是存储在一个被开辟出来的内存片段（间接值部）上）
-   任何映射元素都是不可寻址的



每个数组或者结构体值都是仅含有一个直接部分

-   如果映射类型的元素类型为结构体类型，则无法修改值中的每个结构体元素的单个字段。必须整体地同时修改所有结构体字段
-   数组类型同上



从数组或者切片派生切片（取子切片）

-   派生出来的切片的元素和基础切片（或者数组）的元素位于同一个内存片段上

```
1| baseContainer[low : high] // 双下标形式
2| baseContainer[low : high : max] // 三下标形式
```

```
baseContainer[low : high : cap(baseContainer)] 
```



```
// 双下标形式 
0 <= low <= high <= cap(baseContainer) 
 
// 三下标形式 
0 <= low <= high <= max <= cap(baseContainer) 
```

-   只要上述关系均满足，下标`low`和`high`都可以大于`len(baseContainer)`。但是它们一定不能大于`cap(baseContainer)`
-   如果`baseContainer`是一个零值`nil`切片，只要上面所示的子切片表达式中下标的值均为0，则这两个子切片表达式不会造成恐慌。 在这种情况下，结果切片也是一个`nil`切片

子切片表达式的结果切片的长度为`high - low`、容量为`max - low`

派生出来的结果切片的长度可能大于基础切片的长度，但容量绝不可能大于基础切片的容量



子切片操作有可能会造成暂时性的内存泄露

```
1| func f() []int {
2| s := make([]int, 10, 100)
3| return s[50:60]
4| }
```

开辟的内存块中的前50个元素槽位在它的调用返回之后将不再可见





切片转化为数组指针

-   切片可以被转化为一个相同元素类型的数组的指针类型
-   如果数组的长度大于被转化切片的长度，则将导致恐慌产生
-   转换结果和被转化切片将共享底层元素



切片转化为数组

-   如果数组的长度大于被转化切片的长度，则将导致恐慌产生
-   转换过程中将复制所需的元素，因此结果数组和被转化切片不共享底层元素



使用内置`copy`函数来复制切片元素

-   两个切片的类型可以不同，但是它们的元素类型必须相同（底层类型必须相同）
-   `copy`函数调用的两个实参均不能为类型不确定的`nil`



Pp. 157- 166