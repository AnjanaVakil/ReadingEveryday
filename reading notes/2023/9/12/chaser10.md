### Base
##### Q：Redis为什么快
- redis大部分操作都是内存中完成
- redis他是单线程 所以避免了数据静态
- redis采用了io多路复用+nio 也就是reactor模型 处理客户端请求
- redis把耗时的一些操作（例如aof的merge 快照的保存 删除大key）都交给了后台线程 所以他被耗时操作阻塞

##### Q：为什么Redis要用单线程？
- 因为redis的瓶颈在于内存io而不是cpu
- 使用单线程可维护性高



### 持久化
##### Q：AOF持久化是怎么实现的
- 区别于WAL AOF持久化是有数据丢失的风险的 核心思想就是在执行一条写操作 将这条写操作写入到缓存区当中 然后有三种策略决定写入到硬盘AOF文件的时机
	- always 每一次都刷入硬盘
	- no 将何时刷入交给操作系统
	- everysec 每隔一秒刷入硬盘
- 重写机制，（反复增删后 aof会变得有很多多余数据）当aof文件大于阈值时触发重写机制，此时主进程会fork一个子进程，(**fork的子进程对于共享的数据是写时复制 读时共享**)子进程共享主进程的物理内存，并将数据副本的键值对转化成命令写入到新的aof文件 而在子进程后台重写时 主进程是不阻塞的 他会把重写过程中新增的数据写入到aof重写缓冲区 待子进程重写完成后会将重写缓冲区追加到 aof文件中
##### Q：RDB快照是怎么实现的？
- RDB快照是redis数据库的全量快照 也就是会保存内存中的所有数据已二进制格式保存 保存快照有两种
	- save会阻塞主线程
	- bgsave通过fork创建子进程 在后台进行保存快照 **fork会共享主线程的物理内存，当主线程要写一块数据时 会进行写时复制**
##### Q：RDB快照和AOF如何混合使用？
- 在AOF文件达到阈值触发重写机制时，fork出来的重写子进程首先会先以rdb的方式将数据写入AOF文件 待写入完成后将主线程在重写过程中写入重写缓冲区的数据以aof方式写入aof文件  此时aof文件前半部分是触发重写时redis的全量快照 后半部分是重写过程中主线程新增的数据

### 数据结构
##### Q：redis hash插入5个数据和5000个数据的存储区别
- 如果哈希类型元素小于512个采用listpack 大于的话则采用哈希表

### 集群
##### Q：Redis集群里有几个槽
- 16384

### 数据结构
##### Q：Redis有哪些数据结构？
- string list hash set zset hyperloglo
- g GEO stream

### 缓存
##### Q：如何保证Redis缓存一致性？
- 要保证Redis缓存与数据库数据一致性 要保证更新两者的操作是尽量是原子的 也就是说要保证两者的操作都成功
- 首先肯定是要先更新数据库因为数据库的数据是持久的
- 然后是删除缓存 为了避免删除缓存失败 引入消息队列对redis进行异步操作 也就是需要更新缓存时把需要操作的数据放入消息队列 然后由worker来取操作数据并更新redis 这样子当操作失败还是能重试

##### Q：Redis缓存与数据库数据的同步为什么要删除缓存而不是更新缓存？
- 删除更加的轻量  因为有可能缓存都是一会用不到的 可以等要用到的时候再去数据库中加载（惰性加载）
- 更新缓存操作是更复杂的 更新缓存需要将新的数据写入缓存 消耗更大的带宽 删除只需删除命令

##### Q：缓存雪崩，缓存击穿，缓存穿透怎么办
- 大量key过期或者redis宕机 大批量数据直接涌入底层的慢设备 
	- 均匀的设置过期时间
	- 设置互斥锁(set nx)每次只能允许一个请求来构建缓存
	- 分库分表 水平扩展慢设备 使得能够平摊压力
	- 设置热点数据不过期 会有一个问题 就是当系统内存紧张的时候有些缓存数据会被淘汰 只是需要一个监控线程来及时更新内存 当发生工作线程取缓存失败则通知后台线程去更新
- 针对Redis故障 启用服务熔断暂停业务对缓存服务的访问直接返回默认值 或者启用限流机制 只允许少部分请求发送到数据库，再多的请求就直接拒绝服务
- 缓存穿透是既不在缓存中也不在数据库当中
	- 非法请求限制
	- 缓存空值或者默认值
	- 布隆过滤器

##### Q：Redis的过期删除策略
- 定期删除+惰性删除
- 定期删除是每隔一段时间去抽查n个key看看有没有过期的 如果在这n个key中过期率达到了25%则继续抽查
- 惰性删除

##### Q：Redis内存淘汰策略
- 默认 超过最大内存限制就不再写入任何数据
- volatile-random 随机淘汰设置了过期时间的键值
- ttl 优先淘汰更早过期的键值
- volatile-lru lru 淘汰设置了过期时间的键值
- volatile-lfu lfu 淘汰使用最少的设置了过期时间的键值
- 还有 random-allkey lru、lfu allkey

##### Q：Redis中的lru是怎么实现的
- lru使用哈希+链表实现的 会浪费空间 其次如果发生大量链表头
- redis的对象结构体中维护一个额外的字段 记录最近使用的时间
- 随机取n个值 淘汰最久没有使用的那个
- lfu 则是在字段记录使用频率

### 高可用
