### 持久化
##### Q：AOF持久化是怎么实现的
- 区别于WAL AOF持久化是有数据丢失的风险的 核心思想就是在执行一条写操作 将这条写操作写入到缓存区当中 然后有三种策略决定写入到硬盘AOF文件的时机
	- always 每一次都刷入硬盘
	- no 将何时刷入交给操作系统
	- everysec 每隔一秒刷入硬盘
- 重写机制，（反复增删后 aof会变得有很多多余数据）当aof文件大于阈值时触发重写机制，此时主进程会fork一个子进程，(**fork的子进程对于共享的数据是写时复制 读时共享**)子进程共享主进程的物理内存，并将数据副本的键值对转化成命令写入到新的aof文件 而在子进程后台重写时 主进程是不阻塞的 他会把重写过程中新增的数据写入到aof重写缓冲区 待子进程重写完成后会将重写缓冲区追加到 aof文件中
##### Q：RDB快照是怎么实现的？
- RDB快照是redis数据库的全量快照 也就是会保存内存中的所有数据已二进制格式保存 保存快照有两种
	- save会阻塞主线程
	- bgsave通过fork创建子进程 在后台进行保存快照 **fork会共享主线程的物理内存，当主线程要写一块数据时 会进行写时复制**
##### Q：RDB快照和AOF如何混合使用？
- 在AOF文件达到阈值触发重写机制时，fork出来的重写子进程首先会先以rdb的方式将数据写入AOF文件 待写入完成后将主线程在重写过程中写入重写缓冲区的数据以aof方式写入aof文件  此时aof文件前半部分是触发重写时redis的全量快照 后半部分是重写过程中主线程新增的数据

### 数据结构
##### Q：redis hash插入5个数据和5000个数据的存储区别
- 如果哈希类型元素小于512个采用listpack 大于的话则采用哈希表

### 集群
##### Q：Redis集群里有几个槽
- 16384

### 数据结构
##### Q：Redis有哪些数据结构？
- string list hash set zset hyperloglog GEO stream

### 一致性
##### Q：如何保证Redis缓存一致性？
- 要保证Redis缓存与数据库数据一致性 要保证更新两者的操作是尽量是原子的 也就是说要保证两者的操作都成功
- 首先肯定是要先更新数据库因为数据库的数据是持久的
- 然后是删除缓存 为了避免删除缓存失败 引入消息队列对redis进行异步操作 也就是需要更新缓存时把需要操作的数据放入消息队列 然后由worker来取操作数据并更新redis 这样子当操作失败还是能重试

##### Q：Redis缓存与数据库数据的同步为什么要删除缓存而不是更新缓存？
- 删除更加的轻量  因为有可能缓存都是一会用不到的 可以等要用到的时候再去数据库中加载（惰性加载）
- 更新缓存操作是更复杂的 更新缓存需要将新的数据写入缓存 消耗更大的带宽 删除只需删除命令

##### Q：缓存雪崩，缓存击穿，缓存穿透怎么办
- 大量key过期或者redis宕机 大批量数据直接涌入底层的慢设备 
	- 均匀的设置过期时间
	- 设置互斥锁(set nx)每次只能允许一个请求来构建缓存
	- 分库分表 水平扩展慢设备 使得能够平摊压力
	- 设置热点数据不过期 会有一个问题 就是当系统内存紧张的时候