#### 为什么需要TCP TCP工作在哪一层
TCP工作在传输层  传输层的作用是建立进程到进程的逻辑通信服务
网络层的IP协议是不可靠的是尽力交付 当需要可靠交付则需要在上层实现 所有就有了TCP  面向连接的可靠的基于字符流的传输层协议 他会确保收到的数据完整性 有序性

#### 什么是TCP连接
TCP连接是维护了Socket 四元组以及窗口信息以及序列号的状态组合

#### UDP和TCP有什么区别呢？分别的应用场景是什么
1. tcp是面向连接的得建立好连接之后才能发送数据  udp则是直接发送数据不必建立连接
2. tcp是可靠的 能保证数据到达的可靠 udp是尽力交付不可靠
3. tcp是一对一的连接 而udp可以一对多 多对多
4. tcp有拥塞控制 流量控制
5. 分片不同 tcp数据如果大于MSS则会在传输层就进行分片
6. udp首部长度是固定的 而tcp头部有可选项所以长度不固定
tcp用于可靠交付 例如FTP  HTTP  udp面向无连接所以时延通常来说会更低 用于实时性需求更高的应用 多媒体传输 广播通信

#### TCP和UDP可以使用一个端口吗
可以  因为当主机收到数据包时 可以在IP头知道这个数据包是TCP/UDP然后交给对应的模块处理

#### TCP连接
1. 客户端初始化一个序列号 然后发送SYN包给服务端  进入syn_sent状态
2. 服务端也初始化一个序列 然后将应答号设置为客户端发来的序列号+1 然后回复一个ACK包 服务端将其放入半连接队列中
3. 然后客户端收到服务端发来的syn包 回一个ack包连接建立完成

#### 为什么是三次握手
1. 三次握手才能确定双方有收发数据的能力
2. 同步双方序列号
3. 避免历史连接  假如是两次握手  然后第一次握手阻塞在网络中 客户端没有收到ack 所以超时重发 但是当新的syn抵达前 旧的syn到了 因为只有两次握手 服务端建立了连接  然后新的syn包到了又建立了连接  如果是三次握手 当旧的syn包抵达服务端 服务端此时会发送syn+ack包  然后客户端会发现这是一个历史连接信息 立马发RST中止连接
#### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
防止被下一个相同四元组的连接接收


#### 初始序列号 ISN 是如何随机产生的？
根据四元组信息哈希加上时钟信息

#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
如果说tcp报文交给ip分片 那么有可能分片会丢失tcp头部信息  那么当发生ip包丢失时就要重传所有消息  确保每个分片都有头部信息  当发生丢包时就可以只传丢失的包

#### 第一次握手丢失了，会发生什么？
第一次握手信息丢失，那么客户端将收不到ack消息，当到了超时时间 就会进行超时重发  接着将超时时间翻倍  如果还丢失那么将再次重发  再将超时时间翻倍 直到达到超时重发上限或者收到ack

#### 第二次握手丢失，会发生什么？
客户端会重发syn  服务端会重发syn+ack 直到达到超时重发上限次数

#### 第三次握手丢失了，会发生什么？
服务端重发

#### 什么是 SYN 攻击？如何避免 SYN 攻击？
攻击者不断向服务端发送syn连接请求  使得迅速占满服务端的半连接队列 使服务端无法处理后续的请求
当半连接队列占满后不将连接信息放入半连接队列 而是把计算一个cookie通过syn+ack发送给客户端 然后客户端收到了利用syncookies生成一个合法的ack 将之发回去 然后服务端收到ack判断其合法性再放入accept队列

#### TCP连接断开
主动断开方调用close函数，并向网络对端发送FIN包然后进入FIN_wait1 此时 还可以接收消息但不发送消息了 被动断开方收到FIN包之后回复一个ACK 进入Close_wait状态、fin_wait2 此时等待进程调用close函数此时还可以发送消息但不接收消息了  当进程调用close函数 向对端发送fin包 进入last_ack 收到fin包给对端发送ack并进入timewait状态  2msl后进入close状态
#### 为什么挥手需要四次？
一次FIN是代表着一方不再向另一方发送数据 每次ack向对方回应已经知晓你不再发送数据
当开启了延迟确认的情况 有可能变成三次挥手  ack会等待有数据发送时一起发送 所以第二次挥手有可能变成FIN+ACK

#### 当第三次握手丢失时会发送什么
服务端会重发ack+syn 达到重发次数后断开连接
客户端分成两种情况
如果客户端发送数据没有收到回应会重传这个数据包达到重传次数上限就会断开tcp连接
如果没有发送 那么在很长一段时间过后 tcp会触发保活机制 发送探测报文给网络对端 然后发现这是一个死亡连接

#### 第四次挥手丢失了，会发生什么？
服务端会重发FIN 当客户端再次收到FIN时会重置timewait时间  超时重发时间是每次的两倍  超时重发次数由内核参数指定

#### 为什么 TIME_WAIT 等待的时间是 2MSL？
一个MSL是报文最大生存时间  2MSL时间是报文一来一回的最大时间 当数据包被接收方处理后又会给发送方回应 一来一回最大需要2MSL时间

#### 为什么需要TIME_WAIT
1. 要确保此次连接所有数据包都能在网络中自然消失以免被相同四元组的连接错误接收
2. 帮助被动关闭方正确关闭连接  被动关闭方要受到ack才能优雅正确的关闭

#### 服务器出现大量 TIME_WAIT 状态的原因有哪些？
1. 没有使用长连接 每次请求结束都会断开连接
2. 长连接因为网络原因导致大量超时
3. 长连接的请求数量达到上限

#### 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
1. 没有监听服务端的socket 导致服务端无法感知新连接到来
2. 新连接到来没有accept获取连接，导致大量连接断开连接
3. 没有监听accept后得到的新socket
4. 没有执行close

#### 流量控制
1. 建立tcp连接时双方会协商一个窗口大小 表示接收方在初始时可以接收多少数据
2. 发送方维护发送窗口的长度 已发送但未收到ack  在接收范围内但未发送两个指针
3. 接收方持续监控缓冲区 动态调整窗口大小并将新的窗口大小值告诉 发送端
4. 发送端收到窗口大小信息会动态调整发送窗口大小
5. 当接收窗口为0时 发送端会定期发送一个心跳包 询问是否可以继续发送数据

#### 拥塞控制
流量控制是避免发送方发送大量数据然后淹没接收方
拥塞控制是避免发送大量数据淹没网络
拥塞控制通过几个机制来实现
首先发送端维护一个拥塞窗口cwnd以及一个慢启动门限
当收到一个ack消息那么就会将拥塞窗口加一 直到大于慢启动门限或者发送丢包事件
此时进入拥塞避免状态 收到一个ack 增长 1/cwnd 也就是全部收到后增长一
如果发生超时重传 那将cwnd设置为1  门限设置为cwnd/2接着重新开始慢启动
当发生快速重传时 将cwnd减半 门限也等于cwnd减半后的值
然后进入快速恢复
快速恢复就是如果重发成功就将cwnd设置为原来一半 然后进入拥塞避免

#### TCP如何优化
##### 握手阶段
1. 减少syn重发次数 每次重发syn都会翻倍等待ack时间
2. 减少syn+ack重发次数
3. 增大半连接队列/开启syncookie  避免半连接队列满了 废弃连接 导致又要重新发送syn
4. 增大accept队列 防止accept队列溢出
5. 打开tcp fastopen 也就是第一次连接发送cookie 下次握手发送这个cookie 那么服务端不必在握手完成才能发送队列
##### 挥手阶段
1. 减少fin的重传次数
2. 减少fin_wait2等待时间  这个等待时间本来是等待对方发送fin帮助对方关闭连接  如果超时就会关闭连接
3. 减少可以timewait的tcp连接个数 一旦超过这个阈值就直接断开连接
4. 让新连接可以复用处于timewait状态的连接端口

##### 发送阶段
1. 启用窗口扩大因子功能
2. 打开缓存区自动调节大小功能
3. 扩大tcp可以使用的内存范围