### CHAPTER 12: DESIGN A CHAT SYSTEM

#### Step 1 - Understand the problem and establish design scope

设计哪种类型的聊天应用至关重要。市场上有 Facebook Messenger、微信和 WhatsApp 这样的一对一聊天应用，也有 Slack 这样专注于群聊的办公聊天应用，还有 Discord 这样专注于大型群组互动和低语音聊天延迟的游戏聊天应用。

-   Candidate: 什么类型的聊天app？1对1还是群组？
-   Interviewer: 都支持
-   Candidate: 手机app？web app？还是都有？
-   Interviewer: 都有
-   Candidate: 规模有多大？是初创应用还是大规模应用？
-   Interviewer: 应支持 5000 万日活跃用户（DAU）
-   Candidate: 群聊的群成员上限是多少？
-   Interviewer: 最大一百人
-   Candidate: 聊天应用程序有哪些重要功能？能否支持附件？
-   Interviewer: 一对一聊天、群聊、在线指标。系统仅支持文本信息。
-   Candidate:  有信息大小限制吗？
-   Interviewer: 文本长度应少于 100 000 个字符
-   Candidate: 是否需要端到端加密？
-   Interviewer: 暂时不需要，但如果时间允许，我们会讨论这个问题
-   Candidate: 聊天记录要保存多久？
-   Interviewer: 永久



-   一对一聊天，传输延迟低
-   小组聊天（最多 100 人）
-   在线存在
-   支持多种设备。同一账户可同时登录多个账户
-   推送通知



#### Step 2 - Propose high-level design and get buy-in

-   接收其他客户的信息
-   为每条信息找到合适的收件人，并将信息转发给收件人
-   如果收件人不在线，则在服务器上保留该收件人的信息，直到在线为止

![](https://inasa.dev/image/systemdesign/12/1.png)

客户端打算开始聊天时，会使用一个或多个网络协议连接聊天服务。对于聊天服务来说，网络协议的选择非常重要

大多数客户端/服务器应用程序的请求都是由客户端发起的。聊天应用程序的发送方也是如此。发送方通过聊天服务向接收方发送信息时，使用的是久经考验的 HTTP 协议，这是最常见的网络协议。在这种情况下，客户端会打开与聊天服务的 HTTP 连接并发送信息，通知聊天服务将信息发送给接收方。keep-alive 在这种情况下非常有效，因为 keep-alive 头允许客户端与聊天服务保持持久连接。它还能减少 TCP 握手的次数。HTTP 对发送方来说是个不错的选择，许多流行的聊天应用程序，如 Facebook 等许多流行的聊天应用程序最初都使用 HTTP 发送信息。

不过，接收方的情况要复杂一些。由于 HTTP 是由客户端发起的，因此从服务器发送信息并非易事。多年来，人们使用了许多技术来模拟服务器发起的连接：轮询、长轮询和 WebSocket。



##### Polling

![](https://inasa.dev/image/systemdesign/12/2.png)

轮询是客户端定期询问服务器是否有信息可用的一种技术。根据轮询频率的不同，轮询的成本可能很高。它可能会消耗宝贵的服务器资源来回答一个大部分时间都以 "否 "作为答案的问题。



##### Long polling

![](https://inasa.dev/image/systemdesign/12/3.png)

在长轮询中，客户端保持连接开放，直到有新信息或达到超时阈值。一旦客户端收到新信息，它就会立即向服务器发送另一个请求，重新启动进程。长轮询有几个缺点：

-   发送方和接收方可能无法连接到同一个聊天服务器。基于 HTTP 的服务器通常是无状态的。如果使用轮循进行负载平衡，接收消息的服务器可能无法与接收消息的客户端建立长时间轮循连接
-   服务器无法很好地判断客户端是否断开连接
-   效率低。如果用户不怎么聊天，长轮询在超时后仍会进行周期性连接



##### WebSocket

WebSocket 是最常见的从服务器向客户端发送异步更新的解决方案。

![](https://inasa.dev/image/systemdesign/12/4.png)

WebSocket 连接由客户端发起。它是双向和持久的。它以 HTTP 连接的形式开始，并可通过某种定义明确的握手方式 "升级 "为 WebSocket 连接。通过这种持久连接，服务器可以向客户端发送更新。即使安装了防火墙，WebSocket 连接一般也能正常工作。这是因为它们使用的端口 80 或 443 也是 HTTP/HTTPS 连接所使用的端口。

在发送方使用 HTTP 是一个很好的协议，但由于 WebSocket 是双向的，所以没有什么技术上的理由不把它也用于发送。

![](https://inasa.dev/image/systemdesign/12/5.png)

通过将 WebSocket 用于发送和接收，简化了设计，并使客户端和服务器端的实施更加简单。由于 WebSocket 连接是持久的，因此高效的连接管理对服务器端至关重要。



#### High-level design

WebSocket 因其双向通信而被选为客户端和服务器之间的主要通信协议，但需要注意的是，其他一切都不一定非要使用 WebSocket。事实上，聊天应用程序的大多数功能（注册、登录、用户配置文件等）都可以使用传统的 HTTP 请求/响应方法。

聊天系统分为三大类：无状态服务、有状态服务和第三方集成。

![](https://inasa.dev/image/systemdesign/12/6.png)

##### Stateless Services

无状态服务是传统的面向公众的请求/响应服务，用于管理登录、注册、用户配置文件等。这些是许多网站和应用程序的常见功能。

无状态服务位于负载平衡器之后，负载平衡器的任务是根据请求路径将请求路由到正确的服务。这些服务可以是单体的，也可以是独立的微服务。不需要自己构建很多这样的无状态服务，因为市场上有很多服务可以轻松集成。深入讨论的服务是服务发现。它的主要任务是为客户端提供可连接的聊天服务器的 DNS 主机名列表。



##### Stateful Service

唯一有状态的服务是聊天服务。该服务是有状态的，因为每个客户端都与聊天服务器保持着持久的网络连接。在该服务中，只要服务器仍然可用，客户端通常不会切换到另一个聊天服务器。服务发现会与聊天服务密切协调，避免服务器过载。

##### Third-party integration

对于聊天应用程序来说，推送通知是最重要的第三方集成。它是一种在新消息到达时通知用户的方式，即使在应用程序未运行时也是如此。



##### Scalability

理论上也可以在一台现代云服务器中容纳所有用户连接。服务器可处理的并发连接数很可能是限制因素。在方案中，并发用户数量为 100 万，假设每个用户连接需要 10K 的服务器内存（这只是一个非常粗略的数字，而且与语言选择有很大关系），那么只需要大约 10GB 的内存就可以在一个服务器上容纳所有连接。

如果提出的设计方案是把所有东西都放在一台服务器中，这可能会在面试官的脑海中引起很大的反响。没有哪个技术专家会在一台服务器中设计出这样的规模。单一服务器的设计会导致很多问题。单点故障是其中最大的因素。

不过，从单一服务器设计开始也完全没问题。只要确保面试官知道这是一个起点。

![](https://inasa.dev/image/systemdesign/12/7.png)

-   聊天服务器便于发送/接收信息
-   Presence 服务器管理在线/离线状态
-   API 服务器可处理用户登录、注册、更改个人资料等所有操作
-   通知服务器发送推送通知
-   键值存储用于存储聊天记录。当离线用户上线时，她会看到以前的所有聊天记录



##### Storage

在技术栈的深处是数据层。数据层通常需要花费一些精力才能正确完成。必须做出的一个重要决定是决定使用哪种类型的数据库：关系数据库还是 NoSQL 数据库？为了做出明智的决定，将研究数据类型和读/写模式。

典型的聊天系统中有两类数据。第一类是通用数据，如用户配置文件、设置、用户好友列表、 设置、用户好友列表。这些数据存储在稳健可靠的关系数据库中。复制和分片是满足可用性和可扩展性要求的常用技术。第二种是聊天系统独有的：聊天历史数据。了解读/写模式非常重要。

-   聊天系统的数据量巨大。研究显示 Facebook Messenger 和 Whatsapp 每天要处理 600 亿条信息
-   只有最近的聊天记录才会被频繁访问。用户通常不会查找以前的聊天记录
-   虽然在大多数情况下都会查看最近的聊天记录，但用户可能会使用需要随机访问数据的功能，如搜索、查看您的提及、跳转到特定消息等。数据访问层应支持这些情况
-   一对一聊天应用程序的读写比例约为 1:1

推荐使用键值存储，原因如下：

-   键值存储可轻松实现水平扩展
-   键值存储可提供极低的数据访问延迟
-   关系数据库不能很好地处理长尾数据。当索引变大时，随机存取的成本就会很高
-   键值存储已被其他成熟可靠的聊天应用程序所采用。例如，Facebook messenger 和 Discord 都使用键值存储。Facebook messenger 使用 HBase，Discord 使用 Cassandra

#### Data models

##### Message table for 1 on 1 chat

![](https://inasa.dev/image/systemdesign/12/8.png)

主键是 message_id，它有助于决定信息的顺序。我们不能依靠 created_at 来决定消息的顺序，因为有可能同时创建两条消息。

##### Message table for group chat

![](https://inasa.dev/image/systemdesign/12/9.png)

复合主键为 (channel_id，message_id）。channel_id 是分区键，因为群聊中的所有查询都是在一个频道中进行的。

##### Message ID

message_id 必须满足以下两个要求：

-   唯一
-   按时间排序，即新行的 ID 高于旧行的 ID

首先想到的是 MySql 中的 "auto_increment "关键字。但是，NoSQL 数据库通常不提供这种功能。

第二种方法是使用全局 64 位序列号生成器，如 Snowflake

最后一种方法是使用本地序列号生成器。本地表示 ID 仅在组内唯一。使用本地 ID 的原因是，在一对一信道或群组信道中保持信息序列就足够了。与实现全局 ID 相比，这种方法更容易实现。



Pp. 182-189