### Base
##### Q：Redis为什么快
- redis大部分操作都是内存中完成
- redis他是单线程 所以避免了数据竞争
- redis采用了io多路复用+nio 也就是reactor模型 处理客户端请求
- redis把耗时的一些操作（例如aof的merge 快照的保存 删除大key）都交给了后台线程 所以他被耗时操作阻塞

##### Q：为什么Redis要用单线程？
- 因为redis的瓶颈在于内存io而不是cpu
- 使用单线程可维护性高

##### Q：Memcached和Redis的区别
- Redis只使用单核 而memcached可以使用多核
- Redis支持更多的数据结构
- Redis支持持久化
- Redis原生支持主从同步 集群功能
- redis 是io多路复用模型 memecached是非阻塞io

##### Q：如何做内存优化
- 所要存储的数据不会大于4GB，编译使用32bit的Redis。RDB和AOF文件都是兼容的
- 尽量使用listpack
	- hash list set zset在存储较小的元素时，会使用节约内存的listpack所以尽量使用这四种结构  还可以设置配置提高listpack存储数据上限
- 位运算优化[[美团二面#^c2ce92]]Redis支持按位和按字节操作的命令
- 尽量使用Hash类型存储多字段结构数据 远比string存每个字段的value 省内存
- 

### 持久化
##### Q：AOF持久化是怎么实现的
- 区别于WAL AOF持久化是有数据丢失的风险的 核心思想就是在执行一条写操作 将这条写操作写入到缓存区当中 然后有三种策略决定写入到硬盘AOF文件的时机
	- always 每一次都刷入硬盘
	- no 将何时刷入交给操作系统
	- everysec 每隔一秒刷入硬盘
- 重写机制，（反复增删后 aof会变得有很多多余数据）当aof文件大于阈值时触发重写机制，此时主进程会fork一个子进程，(**fork的子进程对于共享的数据是写时复制 读时共享**)子进程共享主进程的物理内存，并将数据副本的键值对转化成命令写入到新的aof文件 而在子进程后台重写时 主进程是不阻塞的 他会把重写过程中新增的数据写入到aof重写缓冲区 待子进程重写完成后会将重写缓冲区追加到 aof文件中
##### Q：RDB快照是怎么实现的？
- RDB快照是redis数据库的全量快照 也就是会保存内存中的所有数据已二进制格式保存 保存快照有两种
	- save会阻塞主线程
	- bgsave通过fork创建子进程 在后台进行保存快照 **fork会共享主线程的物理内存，当主线程要写一块数据时 会进行写时复制**
##### Q：RDB快照和AOF如何混合使用？
- 在AOF文件达到阈值触发重写机制时，fork出来的重写子进程首先会先以rdb的方式将数据写入AOF文件 待写入完成后将主线程在重写过程中写入重写缓冲区的数据以aof方式写入aof文件  此时aof文件前半部分是触发重写时redis的全量快照 后半部分是重写过程中主线程新增的数据

### 集群
##### Q：Redis集群里有几个槽
- 16384

### 数据结构
##### Q：redis hash插入5个数据和5000个数据的存储区别
- 如果哈希类型元素小于512个采用listpack 大于的话则采用哈希表
##### Q：Redis有哪些数据结构？
- string list hash set zset hyperloglo
- g GEO stream
##### Q：string类型
1. 应用场景
	可以存字符串，数字，还可以以二进制编码存储图片，音频，视频等等，可以用string缓存用户信息，同时也可以用于计数
2. 扩容策略
	预分配冗余空间 小于1mb每次加倍扩容，大于1mb后每次扩容增加1mb，最大不能超过512
3. 内部编码
	1. int是8个字节的长整型  保存的是整数
	2. embstr 小于等于44个字节的字符串 把redis object（对象元信息）和sds分配在同一个64B的内存块中 分配一次内存 并且是只读的不能修改  如果要修改会先将他转为raw再修改
	3. raw是大于44个字节的字符串 redis object和sds在两个不同的内存块中 redis object保存了指向了sds的指针 需要分配两次内存

##### Q：Hash类型
1. 应用场景
	存储有多个属性的结构 如果使用json存储在一个string中那么比较难于修改和获取部分属性内容
2. 内部编码
	1. listpack 元素个数小于阈值，并且value大小也小于阈值使用listpack 比较省内存
	2. hashtable

##### Q：List类型
1. 应用场景
	1. lpush+lpop实现栈  lpush+rpop实现队列
	2. 生产者lpush 消费者使用brpop实现一个简单的消息队列
2. 内部编码
	1. 整体是链表 节点是listpack
	2. list中越靠内的节点越少访问 两侧根据局部性原理经常访问 所以内部节点采用LZF压缩
	3. LZF压缩就是对重复值进行压缩

##### Q：Set类型
1. 应用场景
	1. 标签功能
	2. spop+srandmember完成抽奖功能
	3. sinter求交集
2. 内部编码
	1. 整数集合 当集合中元素都是64位范围内整数并小于512个 整数集合是有序的
	2. listpack 当集合中元素小于128个 每个元素小于64字节
	3. hashtable

##### Q：Zset类型
1. 应用场景
	1. 排行榜 score位点赞数 member位视频id
2. 内部编码
	1. 小于128个 并且每个元素大小小于64字节时使用listpack
	2. skiplist
### 缓存
##### Q：如何保证Redis缓存一致性？
- 要保证Redis缓存与数据库数据一致性 要保证更新两者的操作是尽量是原子的 也就是说要保证两者的操作都成功
- 首先肯定是要先更新数据库因为数据库的数据是持久的
- 然后是删除缓存 为了避免删除缓存失败 引入消息队列对redis进行异步操作 也就是需要更新缓存时把需要操作的数据放入消息队列 然后由worker来取操作数据并更新redis 这样子当操作失败还是能重试

##### Q：Redis缓存与数据库数据的同步为什么要删除缓存而不是更新缓存？
- 删除更加的轻量  因为有可能缓存都是一会用不到的 可以等要用到的时候再去数据库中加载（惰性加载）
- 更新缓存操作是更复杂的 更新缓存需要将新的数据写入缓存 消耗更大的带宽 删除只需删除命令

##### Q：缓存雪崩，缓存击穿，缓存穿透怎么办
- 大量key过期或者redis宕机 大批量数据直接涌入底层的慢设备 
	- 均匀的设置过期时间
	- 设置互斥锁(set nx)每次只能允许一个请求来构建缓存
	- 分库分表 水平扩展慢设备 使得能够平摊压力
	- 设置热点数据不过期 会有一个问题 就是当系统内存紧张的时候有些缓存数据会被淘汰 只是需要一个监控线程来及时更新内存 当发生工作线程取缓存失败则通知后台线程去更新
- 针对Redis故障 启用服务熔断暂停业务对缓存服务的访问直接返回默认值 或者启用限流机制 只允许少部分请求发送到数据库，再多的请求就直接拒绝服务
- 缓存穿透是既不在缓存中也不在数据库当中
	- 非法请求限制
	- 缓存空值或者默认值
	- 布隆过滤器

##### Q：Redis的过期删除策略
- 定期删除+惰性删除
- 定期删除是每隔一段时间去抽查n个key看看有没有过期的 如果在这n个key中过期率达到了25%则继续抽查
- 惰性删除

##### Q：Redis内存淘汰策略
- 默认 超过最大内存限制就不再写入任何数据
- volatile-random 随机淘汰设置了过期时间的键值
- ttl 优先淘汰更早过期的键值
- volatile-lru lru 淘汰设置了过期时间的键值
- volatile-lfu lfu 淘汰使用最少的设置了过期时间的键值
- 还有 random-allkey lru、lfu allkey

##### Q：Redis中的lru是怎么实现的
- lru使用哈希+链表实现的 会浪费空间 其次如果发生大量链表头
- redis的对象结构体中维护一个额外的字段 记录最近使用的时间
- 随机取n个值 淘汰最久没有使用的那个
- lfu 则是在字段记录使用频率

### 高可用
##### Q：怎么判断 Redis 某个节点是否正常工作？
- 主从节点之间支持双向心跳
	- 主节点每隔10s给从节点发送心跳 判断从节点存活
	- 从节点每隔一秒上报自己的缓冲区偏移值 用于拉取操作序列

##### Q：主从复制架构中，过期key如何处理？
- 一个key如果在主节点过期了那么将把del操作命令同步到从节点

##### Q：Redis是同步复制还是异步复制？
Redis主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点

##### Q：主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？
- replication backlog buffer是所有节点共享的用于同步操作序列
- replication buffer是全量复制和增量复制都会出现 主节点会给每一个从节点配备一个replication buffer用于缓存发送数据