#### 用户态和内核态
- 内核是管理硬件资源并提供上层进程运行环境的软件
- 为了保证内核安全 虚拟空间分成两部分，一部分为内核空间一部分为用户空间
- 为了区分不同权限操作 就有了用户态和内核态(能操作硬件资源)

用户有三种方式切换到内核态使用内核资源
- 系统调用 可控的切入内核态 是由用户自己发起
- 异常  被动的  比如说除0了 缓冲区溢出  缺页
- 中断 外设设备向cpu发送中断信号 然后和异常一样去查中断向量表找到对应的函数执行

#### IO缓冲区
- 读磁盘会先检查page cache是否已经缓冲这个数据，若否则穿透到磁盘中，然后再缓存在page cache中
- 内核直接把数据写入page cache，并把对应的页标为dirty并添加到dirty list里 内核会定期flush进磁盘 否则也可以自己去调用
- page cache会通过lru等页面置换算法定期淘汰页面

#### IO模式
- **程序控制IO** 
	- 用户发起系统调用陷入内核态
	- 系统调用翻译成一个对应设备驱动程序的过程调用
	- 设备驱动程序轮询设备查看是否就绪
- **中断驱动IO** 
	- 用户进程发起系统调用陷入内核态，告知磁盘控制器要读取数据
	- 磁盘控制器将数据从磁盘拷贝到磁盘控制器缓冲区当中
	- 发送中断到中断控制器，如果中断控制器手头有正在处理的中断或者同时到达但优先级更高的中断 这个中断将被忽略，磁盘控制器将会持续发送中断直至手里
	- 中断控制器向cpu发送中断信号
	- cpu保存当前寄存器状态 并中断当前工作 运行磁盘中断服务将磁盘控制器缓冲区拷贝到内核缓冲区
	- 最后cpu再把数据从内核缓冲区拷贝到用户缓冲区
- **DMA IO**
	- 第6步的数据拷贝 从磁盘控制器的缓冲区到主存不一定需要cpu亲自完成，可以借助DMA完成
	- 用户进程通过系统调用陷入内核态 cpu设置dma控制器的寄存器把内核缓冲区地址写入MAR和磁盘文件地址写入ADR，然后把期望读取的字节数写入WC寄存器
	- DMA控制器向磁盘控制器发出命令，通知它从磁盘读取数据到缓冲区当中
	- DMA引导磁盘控制器将数据传输到MAR寄存器地址，也就是内核缓冲区
	- 传输完成 返回一个ack到dma控制器 wc减去相应数据长度，如果wc不为0 重复这个过程
	- 发送中断到中断控制器 直至中断控制器向cpu发送中断信号
	- cpu将数据从内核缓冲区拷贝至用户缓冲区
- **总结**
	- DMA IO虽然减少了一次cpu 拷贝数据  但还是没有避免cpu拷贝
- 