### 事务
##### Q：mysql的事务具有哪些特性？
- A：原子性，即事务中的所有操作要么全部完成要么全部失败回滚，不存在执行到一半的中间状态
- C：一致性，是指数据库能从一个正确的状态转移到另一个正确的状态 C是开发者的责任 C也是数据库最终的目标
- I：隔离性，多个事务并发访问数据库时，一个事务看不到其他事务的运行效果，以及中间状态
- D：持久性，一旦事务被提交，它对数据库的更改就是永久的。即使在系统崩溃后，数据库应该能够恢复到崩溃前的状态
##### Q：事务隔离级别有哪几种？分别是什么？
- 读未提交 RU，一个事务还没提交就会被其他事务看到(**脏读**)
- 读已提交 RC，一个事务提交以后，他做的变更才能被其他事务看到(**不可重复读**)
- 可重复读 RR，一个事务在整个过程中看到的数据从开头都结尾都是保持一致的(**幻读**)
- 串行化，当多个事务对同一条记录发生读写操作时，发生冲突的时候，后访问的事务必须等前一个事务执行完成
##### Q：什么是幻读、脏读、不可重复读、写偏斜
- 幻读，即读出来的结果集数量不同 第一次查询返回了三行 第二次查询返回了四行
- 脏读，一个事务读取到另一个事务未提交的数据
- 不可重复读，一个事务多次读取同一数据返回的结果不同
- 写偏斜，两个事务在读取相同的数据时，并根据这一数据进行数据库的修改操作，导致一个事务的修改被保留，另一个事务的修改被覆盖
##### Q：在可重复读隔离级别下，A事务在执行查询的过程中，B事务在A查询的范围里插入一条新数据，会发生什么，数据能插入成功吗？这种情况下，加的是什么锁？
- 在innoDB存储引擎中 如果A事务执行的是快照读 那么B事务是可以插入成功的 但对于A事务来说是不可见的
- 如果A事务执行的是当前读 那么A事务会在查询范围内上**next-key lock(记录锁+间隙锁)**
##### Q：在真实的业务场景(可重复读隔离级别)对一个表的delete操作应该注意什么 delete加的是什么锁？
- 小批量的删除会给记录上行锁 也就是记录锁
- 大规模的删除可能会上表锁 所以大规模的删除要分批删除 或者会阻塞其他事务
##### Q：InnoDB的MVCC是怎么实现的？
- 首先每一行数据会维护一个db_trx_id字段用于记录最新修改并提交这行数据的事务 以及roll_back指针用于记录这行数据的版本链
- 在可重复读的情况下 会在事务启动时生成一个read view 一个read view维护了最小的活跃事务id 以及最大的活跃事务id 以及未提交的事务id
- 读取一行数据如果他的trx_id小于min_id则是可见的 大于max_id不可见 否则就要判断是否在未提交事务id集合中  如果是的话就要去版本链中找到第一个可见的版本数据
##### Q：可重复读 和 读已提交是怎么实现的？
- 可重复读会在事务一开始就生成一个read view  read view中维护了当前的事务id 以及活跃的事务最小、最大id 以及活跃未提交的事务id列表  并在这个事务中查询数据都会受到read view的限制 具体而言就是查询一行数据要判断他的trx_id 当他小于min_id或者小于max_id并不在活跃id列表中才可见 否则就要去版本链中找到第一个可见的
- 读已提交则是在每一次查询都要创建一个read view