1. 编写的代码能够达到正确可靠、简洁清晰的目标称之为高质量代码
- 各种边界条件是否考虑晚辈
- 异常情况处理，稳定性保证
- 易读易维护

1. 简单性
	1. 消除冗余，简单清晰的逻辑编写代码
	2. 不理解的代码无法修复改进
2. 可读性
	1. 代码是写给人看的，而不是机器
	2. 编写可维护代码的第一步是确保代码可读
3. 生产力
	1. 团队整体工作效率非常重要


#### 编码规范
1. 包中公共符号 都要添加注释
2. 任何既不明显也不简单的公共功能必须注释
3. 任何函数都要注释
4. 不需要注释实现接口的方法

##### 注释
1. 注释应该解释代码作用
2. 注释应该解释代码如何做到
3. 注释应该解释代码实现的原因
	1.  解释代码的外部因素
	2. 提供额外上下文
4. 注释应该解释代码什么情况会出错


##### 命名规范
- 简洁胜于冗长
- 缩略词全大写，但当其位于变量开头不需要导出时，全小写
	- 例如使用ServeHTTP而不是ServeHttp
- 变量距离使用的地方越远，需要携带越多的上下文信息
	- 全局变量在其需要更多的上下文信息，以便在哪都能理解
- 函数名不携带包名的上下文信息，包名和函数名总是成对出现的
- 包名只由小写字母组成
- 简短并包含一定的上下文信息
- 不要与标准库同盟
- 不适用常用变量名作为包名
- 使用单数
- 谨慎的使用缩写

##### 控制流程
- 线性原理，处理逻辑尽量走直线，不要复杂的嵌套分支
- 正常流程代码沿着屏幕向下移动
- 提升代码可维护性和可读性
- 故障问题大多出现在复杂的条件语句和循环语句中

##### 错误和异常处理
- 简单的错误指的是仅出现一次的错误，在其他地方不需要捕获
- 优先使用Errors.New()
- 格式化的需要，使用fmt.Errorf
- 错误的Wrap实际上是提供了一个error嵌套另一个error的能力，从而生成一个error的跟踪链
- 在fmt.Errorf中使用：%w关键字来将一个错误关联至错误链中
- 判定一个错误是否为特定错误使用errors.Is
- 错误链获取特定种类的错误使用errors.As
- **不建议在业务代码中使用panic**
- 调用函数不包含recover会造成程序崩溃
- 若问题可以屏蔽或解决建议使用error
- 当程序启动阶段发生不可逆转的错误时，可以在init或main函数中使用panic
- recover只能在defer的函数中使用
- 嵌套无法生效
- defer只在当前goroutine
###### 小结
error尽可能提供简明的上下文信息链，方便定位问题
panic用于真正异常的情况
recover生效范围，在当前goroutine的被defer的函数中生效
