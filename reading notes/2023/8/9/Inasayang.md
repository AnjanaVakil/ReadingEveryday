### Chapter1: 从零扩展到数百万用户

#### Single server setup

略

#### Database

略

#### Which databases to use?

-   关系型数据库
    -   `MySQL`，`Oracle`，`PostgreSQL`，etc

-   非关系型数据库：`key-value stores`，`graph stores`，`column stores`，`document stores`
    -   `CouchDB`，`Neo4j`，`Cassandra`，`HBase`，`Amazon DynamoDB`，etc

选择非关系型数据库的原因：

-   需要超级低的延迟
-   数据是非结构化的，没有关系型的数据
-   只需要序列化和反序列化数据（`JSON`，`XML`，`YAML`，etc）
-   需要存储大量的数据



#### Vertical scaling vs horizontal scaling

`Vertical scaling`（ aka “`scale up`”）

`Horizontal scaling`（aka  “`scale-out`”）

当流量较低时，垂直缩放是一个不错的选择，垂直缩放的简单性是其主要优势。遗憾的是，它也有严重的局限性。

-   纵向扩展有一个硬限制。不可能在一台服务器上无限增加 CPU 和内存
-   纵向扩展不具备故障切换和冗余功能。如果一台服务器宕机，网站/应用程序就会完全宕机



#### Load balancer

略

#### Database replication

主数据库一般只支持写操作。从数据库从主数据库获取数据副本，只支持读操作。所有修改数据的命令（如插入、删除或更新）都必须发送到主数据库。大多数应用程序所需的读取和写入比例要高得多；因此，系统中从数据库的数量通常大于主数据库的数量。



#### Cache

缓存是一个临时存储区域，用于将昂贵的响应结果或频繁访问的数据存储在内存中，以便更快地处理后续请求。重复调用数据库会极大地影响应用程序的性能。缓存可以缓解这一问题。



#### Cache tier

缓存层是一个临时数据存储层，速度比数据库快得多。拥有独立缓存层的好处包括：更好的系统性能、减少数据库 工作负载，以及独立扩展缓存层的能力。



##### Considerations for using cache

-   何时使用缓存
    -   当数据读取频繁但修改不频繁时，可考虑使用缓存。当数据读取频繁但修改不频繁时，可考虑使用缓存。由于缓存数据存储在易失性内存中，因此缓存服务器并不是持久化数据的理想选择。不是持久化数据的理想选择。例如，如果缓存服务器重新启动，内存中的所有数据就会丢失。因此，重要数据应保存在持久化数据存储区中。
-   过期策略
    -   实施过期策略是一种良好的做法。缓存数据一旦过期，就会从缓存中删除。如果没有过期策略，缓存数据将永久保存在内存中。过期日期最好不要太短，因为这会导致系统过于频繁地从数据库中重新加载数据。同时，过期日期也不宜过长，否则数据会变得陈旧。
-   一致性
    -   包括保持数据存储和高速缓存同步。不一致可能发生是由于数据存储和高速缓存上的数据修改操作不是在单个事务中进行的。在跨多个区域扩展时，保持数据存储和高速缓存之间的一致性具有挑战性。
    -   参考论文`Scaling Memcache at Facebook`
-   减少失败
    -   单个高速缓存服务器是潜在的单点故障（SPOF）
    -   单点故障（SPOF）是指系统中的一个部分，如果它发生故障，整个系统就会停止工作
    -   为避免单点故障，建议在不同的数据中心安装多个高速缓存服务器。另一种建议采用的方法是按一定比例超额配置所需的内存。这可以在内存使用量增加时提供缓冲。
-   驱逐策略
    -   一旦缓存已满，任何向缓存添加项目的请求都可能导致现有项目被移除。这就是所谓的缓存驱逐。最近最少使用（LRU）是最流行的缓存驱逐策略。还可以采用其他驱逐策略，如最不常用（LFU）或先进先出（FIFO），以满足不同的使用情况。



Pp. 5-16