- ### 1.4 操作系统做什么  
	- #### 1.4.1 不让计算机打盹  
		- #card 什么是 multiprogramming  
			- 操作系统发展早期，CPU资源非常受限，如果只能运行一个程序，那么等待IO时需要空转CPU很浪费，因此人们设计了 multiprogramming 的操作系统，引入了监控程序，如果发现某个程序不需要使用CPU资源，就调度其他等待CPU资源的进程运行  
		- #card 什么是 time-sharing system  
			- 但这样，对响应时长要求很高的程序可能就需要等待很久才有机会运行，于是进入了下一个阶段 time-sharing system，每个进程运行一段时间会把CPU让出给其他进程；但这样仍然有一个问题，比如某个进程陷入了死循环，则没有机会再让出进程了；windows 95 就是这么设计的，很容易死机  
		- #card 什么是 multi-tasking system  
			- 于是我们进入了现在非常为人所熟悉的阶段，操作系统接管了所有的硬件资源，并运行在受硬件保护的级别；所有的进程，都运行在一个更低的级别，通过系统调用来访问硬件资源；每个进程有独立的地址空间，根据优先级都有机会访问到CPU；在运行一段时间之后，操作系统会暂停进程并把资源分配给其他进程；这个过程称为抢占式(preemptive)调度。  
	- #### 1.4.2 设备驱动  
		- 更早的时候，应用开发者写程序需要考虑硬件的差别，对每个硬件都需要单独写程序，这是一个灾难。  
		- 操作系统为硬件建立了一种抽象，让应用开发者工作在抽象之上而无需关注底层硬件。在UNIX中，访问硬件设备的方式和访问文件没有区别。繁琐的细节交由硬件驱动完成。操作系统开发者不会为每个硬件都提供驱动，而是定义了一套框架和接口，让硬件厂商自己提供相关的驱动；只要满足接口要求，应用程序开发者即可使用相关的硬件了。  
	-  