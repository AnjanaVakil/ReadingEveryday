#### Consistent hashing

一致散列是一种特殊的散列方式，当重新调整散列表的大小并使用一致散列时，平均只需重新映射 k/n 个键，其中 k 是键的数量，n 是插槽的数量。相比之下，在大多数传统哈希表中，数组插槽数量的变化会导致几乎所有的键都要重新映射。

##### Hash space and hash ring

假设使用 SHA-1 作为散列函数 f，散列函数的输出范围为：x0, x1, x2, x3, ..., xn。在密码学中，SHA-1 的散列空间从 0 到 2^160 - 1。这意味着 x0 对应于 0，xn 对应于 2^160 - 1，中间的所有其他散列值介于 0 和 2^160 - 1 之间。介于 0 和 2^160 - 1 之间

![](https://inasa.dev/image/systemdesign/05/5.png)

通过收集两端，我们得到一个散列环

![](https://inasa.dev/image/systemdesign/05/6.png)



##### Hash servers

使用相同的哈希函数 f，我们根据服务器 IP 或名称将服务器映射到环上。

![](https://inasa.dev/image/systemdesign/05/7.png)

##### Hash keys

这里使用的哈希函数与 "重哈希问题 "中的哈希函数不同

![](https://inasa.dev/image/systemdesign/05/8.png)

##### Server lookup

要确定key存储在哪台服务器上，我们要从环上的key位置开始顺时针旋转，直到找到一台服务器为止。

顺时针方向，key 0 存储在服务器 0 上；key 1 存储在服务器 1 上；key 2 存储在服务器 2 上；key 3 存储在服务器 3 上。

![](https://inasa.dev/image/systemdesign/05/9.png)

##### Add a server

根据上述逻辑，添加一个新服务器只需重新分配一小部分key。

新增服务器 4 后，只需重新分配key 0, 而 k1、k2 和 k3 仍在相同的服务器上。

在服务器 4 添加之前，key 0 保存在服务器 0 上。现在，key 0 将被保存在服务器 4 上，因为服务器 4 是它从key 0 在环上的位置顺时针旋转遇到的第一个服务器。其他key不会根据一致的哈希算法重新分配。

![](https://inasa.dev/image/systemdesign/05/10.png)

##### Remove a server

当服务器被移除时，只有一小部分key需要通过一致的散列重新分配。

当服务器 1 被移除时，只有 key1 必须重新映射到服务器 2。其余的key不受影响。

![](https://inasa.dev/image/systemdesign/05/11.png)

##### Two issues in the basic approach

基本步骤

-   使用均匀分布的散列函数将服务器和密钥映射到环上
-   要知道某个key映射到哪个服务器，请从key位置开始顺时针查找，直到找到环上的第一个服务器为止。

这种方法存在两个问题。

首先，考虑到服务器可以添加或删除，不可能让所有服务器的分区大小保持一致。

A 分区是相邻服务器之间的哈希空间。分配给每个服务器的 分配给每个服务器的环上分区的大小可能非常小，也可能相当大。

![](https://inasa.dev/image/systemdesign/05/12.png)

其次，环上有可能出现key分布不均匀的情况。例如，则大部分key都存储在服务器 2 上。然而，服务器 1 和服务器 3 却没有数据。

![](https://inasa.dev/image/systemdesign/05/13.png)

一种名为虚拟节点或副本的技术被用来解决这些问题。

##### Virtual nodes

虚拟节点指的是真实节点，每个服务器都由环上的多个虚拟节点代表。

服务器 0 和服务器 1 都有 3 个虚拟节点。

3 是任意选择的；而在实际系统中，虚拟节点的数量要大得多。我们不用 s0，而是用 s0_0、s0_1 和 s0_2 来表示环上的服务器 0。同样，s1_0、s1_1 和 s1_2 代表环上的服务器 1。

通过虚拟节点，每台服务器负责多个分区。标签为 s0 的分区（边）由服务器 0 管理。另一方面，标签为 s1 的分区由服务器 1 管理。

![](https://inasa.dev/image/systemdesign/05/14.png)

要查找key存储在哪个服务器上，从key所在位置开始顺时针方向查找环上遇到的第一个虚拟节点。

![](https://inasa.dev/image/systemdesign/05/15.png)

随着虚拟节点数量的增加，key的分布会变得更加均衡。

因为虚拟节点越多，标准偏差就越小，从而导致数据分布均衡。

标准偏差衡量数据的分布情况。

在线研究进行的一项实验结果表明，在有一两百个虚拟节点的情况下，标准偏差介于平均值的 5%（200 个虚拟节点）和 10%（100 个虚拟节点）之间。当我们增加虚拟节点的数量时，标准偏差会更小。但是，需要更多空间来存储虚拟节点的数据。这是一个权衡问题，我们可以根据系统要求调整虚拟节点的数量。

##### Find affected keys

添加或删除服务器时，需要重新分配一部分数据。如何找到受影响的范围来重新分配key？

服务器 4 被添加到环上。受影响的范围从 s4（新添加的节点）开始，围绕环路逆时针移动，直到找到服务器（s3）为止。因此，位于 s3 和 s4 之间的key需要重新分配到 s4。

![](https://inasa.dev/image/systemdesign/05/16.png)

当服务器（s1）被移除时，受影响的范围从 s1（被移除的节点）开始，围绕环路逆时针移动，直到找到服务器（s0）为止。因此，位于 s0 和 s1 之间的key必须重新分配到 s2。

![](https://inasa.dev/image/systemdesign/05/17.png)

#### Wrap up

-   添加或删除服务器时，最小化key会重新分配
-   由于数据分布更均匀，因此易于横向扩展
-   缓解热点密钥问题。对特定分片的过多访问可能会导致服务器过载。试想一下，凯蒂-佩里、贾斯汀-比伯和 Lady Gaga 的数据最终都在同一个分片上。同一个分区。一致的散列法可以更均匀地分配数据，从而缓解这一问题。均匀分布，从而减轻问题

Pp. 75-86