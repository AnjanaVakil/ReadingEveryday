## 总思考
| 文件系统的主要方面 | 描述 |
| --- | --- |
| 数据结构（Data Structures） | 文件系统使用何种类型的磁盘结构来组织其数据和元数据？最初的文件系统（包括以下的vsfs）使用简单的结构，如块或其他对象的数组，而更复杂的文件系统，如SGI的XFS，使用更复杂的基于树的结构。 |
| 访问方法（Access Methods） | 文件系统如何将进程调用（如 open(), read(), write()等）映射到其结构？在执行特定的系统调用期间，读取了哪些结构？写入了哪些结构？所有这些步骤的执行效率如何？ |
| 精神模型（Mental Models） | 通过理解文件系统的数据结构和访问方法，你就能形成对其工作原理的良好精神模型，这是系统思维方式的关键部分。在我们深入第一次实现的时候，试着去发展你的精神模型。 |


## 整体组织

| 数据结构 | 描述 |
| --- | --- |
| 数据区域 (Data Region) | 文件系统用于用户数据的磁盘区域，通常是文件系统的大部分空间。在上述例子中，数据区域占据了64个块中的最后56个。 |
| i节点 (Inodes) | 文件系统中存储文件元数据的结构，包括文件的数据块位置，文件大小，所有者和访问权限，访问和修改时间等信息。在上述例子中，5个块用于存储i节点。 |
| 位图 (Bitmaps) | 文件系统用于跟踪数据块和i节点是否已被分配的结构。位图中的每一位都代表对应的对象/块是否被使用（1为使用，0为空闲）。在上述例子中，有两个位图，一个用于数据区域（数据位图），一个用于i节点表（i节点位图）。 |
| 超级块 (Superblock) | 包含文件系统信息的区块，如i节点和数据块的数量，i节点表的开始位置等。在挂载文件系统时，操作系统首先会读取超级块以初始化各种参数，然后将卷（volume）连接到文件系统树。在上述例子中，超级块在第一个块中。 |


![[$NR)S%$XHYG4B96`PRIDIPG.png]]

## inode
| 字段       | 类型     | 说明     |
| ----------- | ----------- | ----------- |
| inumber      | 数字     | 文件的低级别名称，用于索引对应的inode节点。 |
| inode   | 数据结构        | 存储文件元数据的结构，包含长度，权限，构成块的位置等信息。 |
| size   | 数字        | 文件的大小（字节数）。 |
| type   | 字符串       | 文件的类型（例如，普通文件，目录等）。 |
| mode   | 数字       | 文件的权限，表示该文件是否可以读/写/执行。 |
| uid   | 数字        | 文件的所有者。 |
| time   | 日期/时间       | 文件最后访问的时间。 |
| ctime   | 日期/时间       | 文件创建的时间。 |
| mtime   | 日期/时间       | 文件最后修改的时间。 |
| dtime   | 日期/时间       | inode节点被删除的时间。 |
| gid   | 数字        | 文件所属的组。 |
| links count   | 数字        | 链接到此文件的硬链接数。 |
| blocks   | 数字        | 已分配给此文件的块数。 |
| flags   | 数字        | ext2如何使用此inode的标志。 |
| osd1   | 操作系统相关字段        | 一个操作系统相关的字段。 |
| block   | 磁盘指针集        | 一组磁盘指针（总共15个）。 |
| generation   | 数字        | 文件版本（NFS使用）。 |
| file acl   | 数字        | 新的权限模型，超越模式位。 |
| dir acl   | 数字        | 称为访问控制列表。 |
| faddr   | 不支持的字段        | 一个不支持的字段。 |
| i osd2   | 操作系统相关字段       | 另一个操作系统相关的字段。 |

### 多级索引

| 主题 | 内容 |
| ----------- | ----------- |
| 多级索引 | 为了支持更大的文件，文件系统设计者在inode中引入了不同的结构。其中一个常见的想法是有一个称为间接指针的特殊指针。它不指向包含用户数据的块，而是指向包含更多指针的块，每个指针都指向用户数据。因此，inode可能有一些固定数量的直接指针（例如，12个），和一个间接指针。 |
| 大文件的支持 | 如果文件变得足够大，就会分配一个间接块（从磁盘的数据块区域），并将inode的间接指针槽位设置为指向它。假设一个块是4KB，并且有4-byte磁盘地址，那么添加了另外1024个指针；文件可以增长到（12 + 1024）· 4K或4144KB。 |
| 多级间接指针 | 你可能想支持更大的文件。为此，只需在inode中添加另一个指针：双间接指针。这个指针指向一个包含指向间接块的指针的块，每个间接块包含指向数据块的指针。一个双间接块因此增加了用额外1024 · 1024或1百万4KB块来增长文件的可能性，换句话说，支持超过4GB大小的文件。 |
| 三级间接指针 | 你可能还想要更多，我们打赌你知道这将如何发展：三级间接指针。总的来说，这种不平衡的树被称为多级索引方法，用来指向文件块。|
| 链接基础方法 | 另一个简单的方法在设计inode时使用链表。因此，在inode内部，而不是有多个指针，你只需要一个，指向文件的第一个块。要处理更大的文件，只需在那个数据块的末尾添加另一个指针，依此类推，因此你可以支持大文件。 |
| 指针与范围（区段）法比较 | 指针基础的方法最灵活，但每个文件的元数据量大（尤其是大文件）。区段法更不灵活但更紧凑；尤其是，当磁盘上有足够的空闲空间且文件可以连续布局时，它们工作得很好（这几乎是任何文件分配策略的目标）。 |
| 文件系统的设计 | 许多研究人员已经研究了文件系统及其使用方法，并且几乎每次他们都会发现某些“真理”，这些真理几十年来一直有效。其中一项发现就是大多数文件都很小。这种不平衡的设计反映了这样一个事实；如果大多数文件确实很小，那么最优化这种情况是有意义的。 | 

## 目录组织

| 主题 | 内容 |
| ------ | ------ |
| 目录的组织 | 在vsfs（和许多文件系统）中，目录有一个简单的组织；目录基本上只包含（条目名称，inode编号）的对。对于给定目录中的每个文件或目录，目录的数据块中有一个字符串和一个数字。对于每个字符串，也可能有一个长度（假设名称的大小是可变的）。 |
| 目录示例 | 假设一个目录dir（inode编号为5）里面有三个文件（foo，bar，和foobar），它们的inode编号分别是12，13，和24。dir的磁盘数据可能看起来像这样：<br>inum \| reclen \| strlen \| name <br> 5 4 2 .<br> 2 4 3 ..<br> 12 4 4 foo<br> 13 4 4 bar<br> 24 8 7 foobar |
| 特殊目录 | 注意每个目录都有两个额外的条目，. “点”和.. “点点”；点目录就是当前目录（在这个例子中，是dir），而点点是父目录（在这种情况下，是根）。 |
| 文件删除 | 删除文件（例如，调用unlink()）可以在目录的中间留下空位，因此也应有某种方式标记这一点（例如，使用保留的inode编号，如零）。这种删除是记录长度使用的一个原因：新条目可能会重用旧的、更大的条目，因此在内部有额外的空间。 |
| 目录的存储位置 | 你可能会想知道目录到底存储在哪里。通常，文件系统将目录视为一种特殊类型的文件。因此，目录有一个inode，位于inode表中的某个地方（inode的类型字段标记为“目录”，而不是“常规文件”）。目录有由inode指向的数据块（可能有间接块）；这些数据块存在于我们简单文件系统的数据块区域中。我们的磁盘结构因此保持不变。 |
| 目录存储方式 | 我们还应再次注意，这种简单的目录条目线性列表并不是存储此类信息的唯一方式。与前面一样，任何数据结构都是可能的。例如，XFS [S+96]以B树形式存储目录，使得文件创建操作（在创建文件之前必须确保文件名未被使用）比必须完全扫描的简单列表的系统更快。 |

 | 主题         | 内容 |
| ----------- | ------ |
| 空闲空间管理 | 文件系统必须追踪哪些inode和数据块是空闲的，哪些不是，以便在分配新文件或目录时，可以找到空间。因此，自由空间管理对所有文件系统来说都很重要。在vsfs中，我们有两个简单的位图来完成这项任务。 |
| 空闲空间管理的方式 | 有许多方式可以管理自由空间；位图只是一种方式。一些早期的文件系统使用了自由列表，其中在超级块中保持一个指针指向第一个空闲块；在该块内部保持下一个空闲指针，从而在系统的空闲块中形成一个列表。当需要一个块时，使用头块并相应地更新列表。 |
| 现代文件系统 | 现代文件系统使用更复杂的数据结构。例如，SGI的XFS [S+96]使用某种形式的B-tree来紧凑地表示哪些磁盘块是空闲的。就像任何数据结构一样，不同的时间-空间权衡是可能的。 |
| 文件创建 | 例如，当我们创建一个文件时，我们将必须为该文件分配一个inode。因此，文件系统将在位图中搜索一个空闲的inode，并将其分配给文件；文件系统将必须将inode标记为已用（用1）并最终用正确的信息更新磁盘上的位图。当数据块被分配时，也会发生类似的一系列活动。 |
| 其他考虑因素 | 当为新文件分配数据块时，可能还会考虑其他因素。例如，一些Linux文件系统，如ext2和ext3，在创建新文件并需要数据块时，会寻找一系列的块（比如8个）是空闲的；通过找到这样一系列的空闲块，然后将它们分配给新创建的文件，文件系统保证了文件的一部分会在磁盘上并且是连续的，从而提高性能。这样的预分配策略因此是在为数据块分配空间时常用的启发式方法。 |


## 读取和写入
### 读取
| 主题 | 内容 |
| --- | --- |
| 访问路径：读取和写入 | 理解在读取或写入文件活动期间操作流程是理解文件系统工作方式的第二个关键。 |
| 读取磁盘上的文件 | 文件系统首先需要找到文件的inode，以获取一些基本信息（如权限信息，文件大小等）。文件系统必须能够找到inode，但现在它只有完整的路径名。文件系统必须遍历路径名，从而定位到所需的inode。 |
| 开始遍历 | 所有遍历都从文件系统的根目录开始。因此，文件系统首先从磁盘读取的是根目录的inode。通常，我们在其父目录中找到文件或目录的i-number；根目录没有父目录（根据定义）。因此，根inode号必须是“众所周知”的；当文件系统挂载时，FS必须知道它是什么。在大多数UNIX文件系统中，根inode号是2。因此，要开始此过程，FS读取包含inode号2的块（第一个inode块）。 |
| 读取inode | 一旦读取了inode，FS可以查看它，找到指向数据块的指针，这些数据块包含根目录的内容。FS将使用这些磁盘指针来读取目录，在此情况下查找foo的条目。通过读取一个或多个目录数据块，它将找到foo的条目；一旦找到，FS也将找到foo的inode号（假设它是44），接下来需要它。 |
| 遍历路径名 | 下一步是递归遍历路径名，直到找到所需的inode。在此示例中，FS将接下来读取包含foo的inode的块，然后读取其目录数据，最后找到bar的inode号。因此，open()的最后一步是将其inode读入内存；然后FS可以进行最后的权限检查，在每个进程的打开文件表中为此进程分配一个文件描述符，并将其返回给用户。 |
| 读取文件 | 一旦打开，程序便可以发出read()系统调用以从文件中读取。首次读取（除非已调用lseek()，否则偏移为0）将读取文件的第一个块，查询inode以找到这样一个块的位置；它还可能更新inode以新的最后访问时间。读取将进一步更新此文件描述符的内存中打开的文件表，更新文件偏移，使得下一次读取将读取第二个文件块，等等。 |
| 关闭文件 | 在某些时候，文件将被关闭。这里要做的工作要少得多；显然，应释放文件描述符，但就目前而言，这就是FS真正需要做的所有事情。没有磁盘I/O操作发生。 |
| 注意事项 | 需要注意，open生成的I/O数量与路径名的长度成比例。对于路径中的每个附加目录，我们必须读取其inode以及其数据。使这个情况变得更糟糕的是大目录的存在；在这里，我们只需要读取一个块就可以获取目录的内容，而对于大目录，我们可能需要读取许多数据块才能找到所需的条目。 |

### 写入
| 主题 | 内容 |
| --- | --- |
| 写入磁盘 | 写入文件的过程与读取相似。首先，必须打开文件（如上所述）。然后，应用程序可以发出write()调用，以新的内容更新文件。最后，关闭文件。 |
| 写入与读取的区别 | 与读取不同，写入文件也可能分配一个块（除非块正在被覆写）。当写出一个新文件时，每次写入不仅需要将数据写入磁盘，而且首先需要决定将哪个块分配给文件，因此相应地更新磁盘的其他结构（例如，数据位图）。因此，逻辑上来说，每次写入文件都会生成三个I/O：一个读取数据位图，然后更新它以将新分配的块标记为已使用，一个写入位图（以反映其新的磁盘状态），和一个写入实际块本身。 |
| 文件创建 | 当考虑到创建文件这样一个简单而常见的操作时，写入的流量甚至更糟。为了创建一个文件，文件系统不仅必须分配一个inode，还必须在包含新文件的目录中分配空间。为此所需的I/O流量总量相当高：一个读取inode位图（找到一个空闲的inode），一个写入inode位图（标记为已分配），一个写入新的inode本身（初始化它），一个写入目录的数据（将文件的高级名称链接到其inode编号），以及一个读取和写入目录inode以更新它。如果目录需要扩展以容纳新条目，则还需要额外的I/O（即，对数据位图和新目录块）。所有这些只是为了创建一个文件！ |
| 实例分析 | 例如，创建了文件/foo/bar，并向其写入了三个块。图40.4显示了在open()（创建文件）以及在每次写入4KB的过程中会发生什么。在图中，读取和写入磁盘的系统调用被归为它们发生的原因，而它们可能发生的大致顺序从图的顶部到底部。你可以看到创建文件需要多少工作：在这种情况下，需要10个I/O，走过路径名然后最后创建文件。你也可以看到每个分配写入的成本是5个I/O：一对读取和更新inode，另一对读取和更新数据位图，然后最后写入数据本身。|


## 缓存和缓冲
- 静态和动态划分

