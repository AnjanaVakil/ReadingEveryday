类型不确定值（`untyped value`）和类型确定值（`typed value`）

-   字符串字面量的默认类型是`string`类型。
-   布尔字面量的默认类型是`bool`类型。
-   整数型字面量的默认类型是`int`类型。
-   `rune`字面量的默认类型是`rune`（即`int32`）类型。
-   浮点数字面量的默认类型是`float64`类型。
-   如果一个字面量含有虚部字面量，则此字面量的默认类型是complex128类型。



类型不确定常量的显式类型转换

-   显式类型转换的形式为`T(v)`，表示将值`v`转换为类型`T`。
-   对于一个特定的类型`T`，`T(v)`并非对任意的值`v`都合法。 



如何确保转换`T(v)`是合法的

-   `v`可以表示为T类型的一个值。 转换结果是一个类型为`T`的类型确定常量值。
-   `v`的默认类型是一个整数类型（`int`或者`rune`） 并且`T`是一个字符串类型。



一个类型不确定数字值所表示的值可能溢出它的默认类型的表示范围。

一个溢出了它默认类型表示范围的类型不确定数字值是不能被转换到它的默认类型的（将编译报错）。

有时一个显式转换形式必须被写成`(T)(v)`以免发生歧义(当`T`不是一个标识符)。



类型推断（`type deduction or type inference`）

-   （具名）常量声明（`constant declaration`）：具名常量都是布尔、数字或者字符串值
-   类型确定具名常量

```
const MaxUint uint = (1 << 64) - 1
```

这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的。 因为一个`uint`值在32位操作系统上的尺寸是32位， `(1 << 64) - 1`将溢出`uint`。

那么如何声明一个代表着最大`uint`值的常量呢？

```
const MaxUint = ^uint(0)
```

这个声明在64位和32位的操作系统上都是合法的。

```
const MaxInt = int(^uint(0) >> 1)
```

表示最大的int值。



```
const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0
const Is32bitOS = ^uint(0) >> 32 == 0
```

表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。



Pp. 31-38