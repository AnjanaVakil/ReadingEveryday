## 概括
| 主题 | 描述 |
| --- | --- |
| 内核中的异常处理流程 | 当内核在CPU上运行时，内核将stvec寄存器指向kernelvec函数。kernelvec将所有的32个寄存器保存在栈中，以便被中断的内核代码可以无干扰地恢复。 |
| 寄存器的保存 | kernelvec将寄存器保存在被中断的内核线程的堆栈上。如果异常导致线程切换，被中断线程的保存的寄存器安全地留在其堆栈上。 |
| 设备中断和异常的处理 | kerneltrap函数处理两类陷阱：设备中断和异常。设备中断调用devintr进行处理；异常在xv6内核中总是会导致致命错误，内核会调用panic并停止执行。 |
| 时钟中断的处理 | 如果kerneltrap因时钟中断被调用，并且一个进程的内核线程正在运行，kerneltrap会调用yield函数让其他线程有机会运行。 |
| 返回到被中断的代码 | kerneltrap工作完成后，恢复可能被yield改变的控制寄存器，并返回到kernelvec。kernelvec从堆栈弹出保存的寄存器并执行sret，复制sepc到pc，并恢复被中断的内核代码的执行。 |
| 从用户模式到内核模式的切换 | 在CPU从用户模式进入内核模式时，xv6将stvec设置为kernelvec。在内核开始执行但stvec仍然设置为uservec的时间窗口中，确保不会发生设备中断。|
![[vCEHNFSV.svg]]
