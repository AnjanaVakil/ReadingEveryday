### Weak Isolation Levels
ACID 中的 isolation 应该看起来没有发生并发，可串行化的隔离会保证事务的最终执行结果和串行执行结果相同。但缺点是可串行化的隔离会影响性能，因此许多数据库不愿意牺牲性能，故采用了更弱的隔离级别。

#### 1. Read Commited
读已提交提供了以下保证：
1. 读数据库时，只能看到已成功提交的数据，防止脏读。
2. 写数据库时，只会覆盖已成功提交的数据，防止脏写。

##### No dirty reads
脏读定义：加入某个事务已经完成部分数据写入，但是事务尚未提交，其它事务能看到其未提交的数据。

脏读的场景：
* 一个事务可能读到其它事务的部分更新。
* 事务发生中止，所有的写入都需要回滚，若一个事务看到了即将被回滚的数据，则发生了脏读。

##### No dirty writes
脏写定义：如果两个事务同时更新了相同的对象，如果先前的写入时尚未提交事务的一部分，则发生了脏写。
防止脏写的方法：推迟第二个写请求，只至其前面的事务完成提交或中止。

防止脏写可以避免一下问题：
* 事务同时更新多个对象，脏写导致了非预期的错误结果。

##### Implementing read committed
Oracle 11g, PostgreSQL, SQL Server 2012, MemSQL 等数据库默认使用读已提交隔离。

在实现上，数据库通常使用行级锁来防止脏写，对于一个对象，一个事务必须拿到特定对象的锁，如果另一个事务尝试更新该对象，其必须等待先前事务提交或中止后，获得锁以后才能继续。

防止脏读：使用和脏写一样的锁。
但读锁的方式并不可行，运行时间长的写事务会导致其它只读事务等待时间过长，会影响只读事务的响应时间，可操作性差，甚至导致整个应用层变慢。
因此，大多数数据库，对于每个待更新的对象，数据库会维护其新值和旧值两个版本，事务提交前使用旧值，提交成功后，才切换到读新值。