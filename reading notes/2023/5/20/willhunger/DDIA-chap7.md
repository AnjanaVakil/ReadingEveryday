#### 2. Single Object and Multi-Object Operations
##### Single-object write
如果向数据写入 20KB 的 JSON 文档：
* 网络中断了，数据库仅存储了部分片段数据；
* 电源故障，磁盘覆盖时的新值和旧值是否会混杂在一起；
* 写入时，存在其它客户端读取该文档。

存储引擎的设计是：在单节点、单个对象层面提供原子性和隔离性（例如 key-value pair）。相关机制：WAL，Lock，atomic operation，compare and set。

上述单对象操作可以防止多个客户端并发修改同一对象时的更新丢失问题，但是，其并不是通常意义上的事务。通常意义上的事务时针对多个对象，将多个操作聚合成一个逻辑执行单元。

##### The need for multi-object transaction
许多分布式数据库不支持多对象事务，因为出现跨分区时，多对象事务难以正确实现，且存在性能开销。

多对象事务的常见场景：
* 关系性数据库中的外键约束。
* 文档性数据库中，若出现了非规范化数据，则需要一次更新多个文档。
* 带有二级索引的数据，每次更改值时，需要同步更新索引。

没有原子性保证，错误和异常处理会变得更复杂；缺乏隔离性会导致奇怪的并发问题。

##### Handling errors and aborts
事务的一个关键特性：意外情况下，所有操作被中止，随后可以进行安全的重试。
> 但并不是所有的系统都遵循。例如在无主节点复制的数据存储在遇到错误时，并不会撤销已完成的操作，需要应用程序来负责从错误中恢复。

Django 和 Rails ActiveRecord 这样的 ORM 框架，事务出现异常时，不会进行重试，仅仅抛出堆栈信息。

重试中止的事务并不完美：
* 事务已经成功，但是返回消息返回至客户端时发生网络错误；这种情况下会导致事务重复执行。
* 系统负载高的情况下，重试会造成更高的系统负载；可以设定重试次数的上限。
* 某些错误情况下的重试没有意义，例如违反约束。
* 事务会产生其它副作用的情况下，重试不太可行。参考两阶段提交与原子提交。
* 如果应用程序在重试过程中失败，没有其它保障让应用程序充实，则会导致数据丢失。