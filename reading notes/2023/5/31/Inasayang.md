协程（`goroutine`）

-   协程有时也被称为绿色线程。绿色线程是由程序的运行时（`runtime`）维护的线程。
-   一个绿色线程的内存开销和情景转换（`context switching`）时耗比一个系统线程常
    常小得多。 只要内存充足，一个程序可以轻松支持上万个并发协程。
-   Go不支持创建系统线程，所以协程是一个Go程序内部唯一的并发实现方式。

>   `log`标准库中的打印函数是经过了同步处理的，而`fmt`标准库中的打印函数却没有被同步。



并发同步（`concurrency synchronization`）

-   数据竞争（`data race`）
    -   在一个计算向一段内存写数据的时候，另一个计算从此内存段读数据，结果导致读出的数据的完整性得不到保证
    -   在一个计算向一段内存写数据的时候，另一个计算也向此段内存写数据，结果导致被写入的数据的完整性得不到保证。
-   并发编程的任务
    -   调度不同计算，控制它们对资源的访问时段,避免数据竞争
    -   决定需要开启多少计算
    -   决定何时开启、阻塞、解除阻塞和结束哪些计算
    -   决定如何在不同的计算中分担工作负载



协程的状态

-   注意，一个处于睡眠中的（通过调用`time.Sleep`）或者在等待系统调用返回的协程被认为是处于运行状态，而不是阻塞状态。
-   当一个新协程被创建的时候，它将自动进入运行状态
-   一个协程只能从运行状态而不能从阻塞状态退出
-   一个处于阻塞状态的协程不会自发结束阻塞状态，它必须被另外一个协程通过某种并发同步方法来被动地结束阻塞状态。
-   如果一个运行中的程序当前所有的协程都出于阻塞状态，则这些协程将永远阻塞下去，程序将被视为死锁了。 当一个程序死锁后，官方标准编译器的处理是让这个程序崩溃。



协程的调度

-   在任一时刻，只能最多有和逻辑CPU数目一样多的协程在同时执行。
-    每个逻辑CPU在同一时刻只能最多执行一个协程。
-   Go运行时（`runtime`）必须让逻辑CPU频繁地在不同的处于运行状态的协程之间切换，从而每
    个处于运行状态的协程都有机会得到执行。 
-   运行状态被细分成了多个子状态。 一个处于排队子状态的协程等待着进入执行子状态。一个处于执行子状态的协程在被执行一会儿之后将进入排队子状态。（睡眠和等待系统调用返回子状态被认为是运行状态，而不是阻塞状态。）
-   M-P-G模型
    -   M表示系统线程，P表示逻辑处理器（并非上述的逻辑CPU），G表示协程。
    -   大多数的调度工作是通过逻辑处理器（P）来完成的。 逻辑处理器像一个监工一样通过将不同的处于运行状态协程（G）交给不同的系统线程（M）来执行。
    -   一个协程在同一时刻只能在一个系统线程中执行。一个执行中的协程运行片刻后将自发地脱离让出一个系统线程，从而使得其它处于等待子状态的协程得到执行机会。
    -   默认初始逻辑处理器的数量和逻辑CPU的数量一致
    -   对于某些文件操作十分频繁的程序，设置一个大于`runtime.NumCPU()`的`GOMAXPROCS`值可能是有好处的。



延迟函数调用（`deferred function call`）

-   一个函数调用可以跟在一个`defer`关键字后面，成为一个延迟函数调用。
-   当一个延迟调用语句被执行时，其中的延迟函数调用不会立即被执行，而是被推入由当前协程维护的一个延迟调用队列（一个后进先出队列）。



一个延迟调用可以修改包含此延迟调用的最内层函数的返回值

```go
1|package main
2|
3|import "fmt"
4|
5|func Triple(n int) (r int) {
6| 	defer func() {
7| 		r += n // 修改返回值
8| 	}()
9|
10| return n + n // <=> r = n + n; return
11|}
12|
13|func main() {
14| fmt.Println(Triple(5)) // 15
15|}
```



延迟函数调用的必要性和好处

-   恐慌/恢复特性



协程和延迟调用的实参的估值时刻

-   一个延迟调用的实参是在此调用对应的延迟调用语句被执行时被估值的。
-   一个匿名函数体内的表达式是在此函数被执行的时候才会被逐渐估值的，不管此函数是被普通调用还是延迟/协程调用。

```go
1|package main
2|
3|import "fmt"
4|
5|func main() {
6|	func() {
7| 		for i := 0; i < 3; i++ {
8| 			defer fmt.Println("a:", i)
9| 		}
10| }()
11| fmt.Println()
12| func() {
13| 	for i := 0; i < 3; i++ {
14| 		defer func() {
15| 			fmt.Println("b:", i)
16| 		}()
17| 	}
18| }()
19|}
```



```
a: 2
a: 1
a: 0

b: 3
b: 3
b: 3
```

解释

-   第一个循环中的`i`是在`fmt.Println`函数调用被推入延迟调用队列的时候估的值
-   第二个循环中的`i`是在第二个匿名函数调用的退出阶段估的值（此时循环变量`i`的值已经变为3）



Pp. 94-104