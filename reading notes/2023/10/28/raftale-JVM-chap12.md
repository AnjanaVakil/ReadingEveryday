## 针对long和double型变量的特殊规则

Java内存模型对64位的数据类型long和double定义了一个宽松的规定，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。但实际上，虚拟机基本上都将long和double实现为原子性的访问，所以基本上不需要特殊考虑long和double。

## 原子性、可见性与有序性

Java内存模型是围绕着在并发过程中如何处理原子性、可见性、有序性这三个特征来建立的。

## 原子性

Java内存模型直接保护的原子性变量操作包括read、load、assign、use、store、write这六个，基本数据类型的访问、读写都是具备原子性的。如果应用场景需要更大范围的原子性保证，lock和unlock可以使用来保证同步代码块也具有原子性。实际上lock和unlock被monitorenter和monitorexit封装，monitorenter和monitorexit又被synchronized封装。

## 可见性

可见性是指：当一个线程修改了共享变量的值时，其他线程能够立刻得知这个修改，并在下一次读取中从主存中读取最新的值。volatile保证了多线程操作下时变量的可见性，除了volatile之外，synchronized和final也能实现可见性。

同步块的可见性是因为：对一个变量执行unlock操作之前，必须先把此变量同步回主存中执行store、write操作；

final的可见性是因为：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么其他线程就能看见final字段的值。

## 有序性

如果在本线程内观察，所有操作都是有序的：「线程内表现为串行的语义」

如果在一个线程中观察另一个线程，所有操作都是无序的，原因是：指令重排序、工作内存和主内存同步延迟（可见性）。

volatile和synchronized保证了有序性。

happens-before原则也保证了有序性。

## happens-before

JVM为程序中所有的操作定义了一个偏序关系，称之为Happens-Before。要想保证执行操作B的线程看到A的结果，无论A和B是否在一个线程中，那么A和B之间必须满足Happens-Before关系。如果两个操作之间缺乏Happens-Before关系，那么JVM可以对它们进行重排序。



Java内存模型下天然的Happens-Before的规则有：

1. Program Order Rule：如果控制流（非代码中）操作A在操作B之前，那么A happens-before B。
2. 监视器锁：同一个锁的unlock必须happens before后面的lock；
3. volatile变量规则：对volatile变量的写入操作必须happens-before后面对该变量的读操作；
4. Thread Start Rule：线程上对Thread.start的调用必须happens-before后面该线程的其他任何操作之前
5. Thread Termination Rule：线程中的任何操作都先于发生于对此线程的终止检测，我们可以通过Thread.join()， isAlive()的返回值等手段检测线程是否已经终止运行。
6. Thread Interruption Rule：对线程interrupt()方法的调用先发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()等方法检测到是否有中断发生。
7. 对象终结器规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行完成）先发生于它的finalize()方法的开始。
8. 传递性： If A happens-before B, and B happens-before C, then A happens-before C.

Java无须任何同步手段保障就能成立的happens-before有且只有这八条规则。衡量并发安全问题都是以Happens-before原则为推导，而不是看代码的顺序。

# Java与线程

并发不一定要依赖多线程，但Java的并发基本上都是围绕着线程的。

## 线程的实现

线程是比进程更轻量的调度执行单位，各个线程既可以共享进程资源，又可以独立调度。

实现线程主要有三种方式：

1. 使用内核线程实现（1:1实现）
2. 使用用户线程实现（1:N实现）
3. 使用用户线程加轻量级进程混合实现（N:M实现）



### 内核线程实现

内核线程（Kernel-Level Thread, KLT）是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会使用内核线程，而是使用内核线程的一种高级接口：轻量级进程（Light Weight Process， LWP）。轻量级进程都由一个内核线程支持，所有它是独立的调度单元，即使其中某一个LWP被阻塞，也不会影响整个进程继续工作。

轻量级进程的局限性：线程创建、析构、同步都需要进行系统调用，系统调用需要在用户态和内核态中来回切换，**开销非常大**。并且LWP还需要消耗内核线程，占用内核线程的栈空间，因此一个系统支持LWP的**数量也是有限**的。




### 用户线程实现

广义来讲，不是内核线程都可以看作用户线程（User Thread， UT），所以LWP也可以看作用户线程。

狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不用知道用户线程的存在及如何实现，也就是它的建立、同步、销毁、调度都完全是在用户态中完成，其抽象策略由用户态自行制定。

用户线程的优势就是与内核线程进行了解耦，如果用户线程实现的好，甚至不需要切换到内核态，非常高效。

局限性就是 线程的创建调度、阻塞如何处理、如何映射到处理器上这些问题的解决会非常复杂。


### 混合实现

线程除了依赖内核线程和完全由用户程序自己实现之外，还有一种将内核线程和用户线程混合使用的实现方式。

LWP则是用户线程与内核线程之间的桥梁，用户线程的创建销毁还是完全建立在用户空间，保持了操作的廉价，但使用内核线程处理线程调度及映射，保证了调度实现没有那么复杂。




### Java线程的实现

Java线程实现不受JVM规范的约束。

不同的JVM实现不同，HotSpot是使用的内核线程和LWP的1:1实现，这也是目前主流的实现。所以线程是通过内核调度，从一个线程切换到另一个线程就涉及到了上下文切换。

## Java线程调度

线程调度是指系统为线程分配处理器使用权的过程。调度方式有两种：

1. 协同式线程调度：线程执行时间由线程自身控制，执行完任务才通知系统进行线程切换。
2. 抢占式线程调度：线程切换由系统控制。

Java使用的是抢占式线程调度，虽然有线程优先级，但Java线程都是被映射到系统的原生线程上，所以优先级不是稳定的，线程调度还是由操作系统决定的。

甚至线程优先级还可能被操作系统修改。

## 状态转换

Java定义了6种线程状态：

1. New：创建尚未启动
2. Runnable：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也可能正在等待着操作系统为它分配执行时间。
3. Waiting：于该状态的线程不会被分配处理器执行时间，不过必须无限等待被其他线程显式唤醒。

1. 1. Object::wait()
2. Thread::join()
3. LockSupport::part()

1. Timed Waiting：处于该状态的线程不会被分配处理器执行时间，不过无须无限等待被其他线程显式唤醒，在一定时间后它们会由系统自动唤醒。以下方法会让线程进入该状态：

1. 1. Thread.sleep()
2. Object::wait(long timeout)
3. Thread::join(long timeout)
4. LockSupport::parkNanos(), parkUntil()

1. Blocked：特指线程在等待获取互斥锁的时候。
2. Terminated



# Java与协程

## 内核线程的局限

如今分布式架构的服务力求减少单个服务的复杂度，通过组合多个服务来增加扩展性和复用性，这要求单个服务的响应必须要快，这就导致了单个服务提供计算时间的减少。由于Java线程实现是1:1的内核线程映射，线程池中切换开销可能接近于计算本身的开销。这就造成了极大的浪费。

## 协程的复苏

内核线程切换的开销来自于保护和恢复线程上下文的成本，这个开销对操作系统来说必然是巨大的。



由于最初多数的用户线程是被设计为协同式调度的，所以它有一个别名：协程（Coroutine），但协程却不一定是协同式调度的。协程分为两种：

1. 有栈协程：每个协程都有自己的调用栈，类似于线程的调用栈。典型代表有Golang 中的 goroutine、Lua 中的协程、Java的虚拟线程
2. 无栈协程：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。典型代表有ES6的 await/async、Python 的 Generator、C++20 中的 cooroutine



有栈协程的一般实现是：在内存中给每个协程开辟一个栈内存，当协程挂起时会将它的运行时上下文（即栈空间）从系统栈中保存至其所分配的栈内存中，当协程恢复时会将其运行时上下文从栈内存中恢复至系统栈中。

有栈协程的栈空间一般都是在堆空间开辟的，运行时上下文切换时还是有一定的开销的。不过它的好处就是可以在函数执行的任意位置挂起协程。



协程的优势是轻量。

协程的局限性是实现复杂。

## Java的解决方案

Java中，协程也称为虚拟线程。虚拟线程在JDK19中被引入，在JDK21成为正式版。
