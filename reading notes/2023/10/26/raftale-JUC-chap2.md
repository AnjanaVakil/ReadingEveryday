要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变状态的访问。

对象的状态是指存储在状态变量（实例或静态feild）中的数据。

共享意味着变量可以由多个线程同时访问，可变意味着变量的值在其生命周期可以发生变化。

一个对象是否是线程安全的，取决于它是否被多个线程访问。这个讨论的是对象如何在程序中被使用，而不是程序要实现的功能。要使得对象是线程安全的，必须要使用同步机制来协同对对象可变状态的访问，这里说的同步，包含了synchronized， volatile， 显式锁、原子变量。

线程安全的三种方式：

1. 不在线程之间共享该状态变量
2. 将状态变量修改为不可变的变量
3. 在访问状态变量时使用同步

一开始设计一个线程安全的类要比后面修改更容易。

任何情况下，只有当类中包含自己的状态时，线程安全类才是有意义的。线程安全性是一个在代码上使用的术语，但它只能与状态相关，因此只能应用于封装其状态的整个代码，这可能是一个对象，也可能是整个程序。



# 什么是线程安全性

线程安全性的定义：当多个线程访问某个类时，这个类始终表现出正确的行为，那么这个类是线程安全的。正确性是指：某个类的行为与其规范完全一致，规范通常是各种不变性条件来约束对象的状态，以及定义各种后验条件来描述对象操作的结果。





无状态对象一定是线程安全的，比如servlet。

## 原子性

count++不是原子性的操作，多线程环境下不是线程安全的。

并发编程中，由于不恰当的执行时序而出现不正确的结果



## 竞态条件

竞态条件（race condition）：由于不恰当的执行时序而出现不正确的结果。



有两种常见的竞态条件：

1. check-then-act：先检查后执行

1. 1. 首先观察到某个条件为真，然后根据这个观察结果采用相应的动作，但事实上，在观察到这个结果和执行某个动作之间，观察结果可能变得无效，从而导致各种问题。
2. 比如：不存在就添加

1. read-modify-write：

1. 1. 基于对象之前的状态来定义对象状态的转换。
2. 不是原子性，状态转换就可能产生问题





race conditon问题的本质是：基于一种可能失效的观察的结果做出判断或执行某种计算。





## 复合操作

我们将check-then-act和read-modify-write称之为复合操作，这类复合操作为了保证线程安全，必须是以原子方式执行。原子方式执行能够避免执行中状态被其他线程修改的问题。



# 加锁机制



多个变量之间可能存在某种不变性条件，多线程操作可能破坏这个不变性条件。要保证状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。



## 内置锁

Java提供了一种内置锁机制来支持原子性：同步代码块。

```java
synchronized(lock) {
    
}
```

每个java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或者监视器锁。

线程会在进入同步代码块之前自动获得锁，并且在退出同步代码块时自动释放锁。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

内置锁是一种互斥锁、独占锁。

## 重入

实现互斥锁的思想是：当某个线程请求一个其他线程持有的锁时，发出请求的线程会被阻塞。

但某个线程试图获得一个已经由它自己持有的锁时，这个请求应当是成功的，那说明这个锁是可重入的。

重入意味着获取锁的 操作粒度是线程。

如果没有可重入机制，下面的代码就会发生死锁。

```java
public class Widge {
    public synchronized void doSomething() {
        System.out.println("Widge LoggingWidget");
    }
}

public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println("enter LoggingWidget");
        super.doSomething();
    }
}
```

重入的实现方法是：为每个锁关联一个计数值和一个所有者线程，每进入同步代码块，计数值就加一，每退出同步代码块，计数值就减一，计数值为0时表示锁被释放。

# 用锁来保护状态

独占锁保证了同步代码块是以串行形式来访问的，因此可以通过锁来构造一些一些协议实现对共享状态的独占访问。只要始终遵循这些协议，就能确保状态的一致性。

一种常见的错误，只有在写入共享变量时才需要使用同步，但实际上并非如此，因为变量还有可见性问题

之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。这可能并不是一个好的设计，它可能会引起混乱，而且还迫使JVM需要在对象大小和加锁性能之间进行权衡。



一种常见的加锁约定是：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步。例如Vector类，但这种策略的缺点是：如果添加新方法时忘记了使用同步，那么这种加锁协议就会被破坏。



串行执行在并发常见下很容易出现性能问题或者活跃性问题。

# 活跃性与性能

持有锁的时间太长，会增加活跃性和性能问题，缩小同步代码块的范围能显著提高性能。

同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性、简单性、性能。
