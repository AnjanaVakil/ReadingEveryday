### Base
##### Q：Innodb和MyISAM的区别
- innodb支持事务 
- innodb支持行锁 myisam只支持表锁
- innodb支持外键 myisam不支持 innodb是聚集索引 myiasm的索引中保存数据的物理地址
- innodb支持完整性约束。并且在发生崩溃时能通过log恢复
- myisam会保存表中具体的行数 所以查询表中有几行会快一点

##### Q：原子性怎么实现的
- undolog 事务如果没有提交成功则会通过undolog进行回滚
- redolog 一个事务完成了会先写入redo log 不会因为崩溃而导致这一个事务明明提交成功了但却找不到数据
##### Q：持久性怎么实现的
- redolog 事务提交成功了能通过redolog实现崩溃恢复 redolog本质是对脏页数据的备份 当脏页持久化到磁盘以后 将redolog进行擦除 保证redolog有且仅有未持久化的数据
- binlog 每一条完成的数据都会先写入binlog buffer 事务提交后写入binlog日志中

##### Q：binlog和redolog的区别和作用
- binlog由server层实现保存的是全量日志 用于备份和主从同步
- redolog保存的脏页的数据 用于崩溃恢复


##### Q：如何保证redolog和binlog的一致性
- 二阶段提交 
	- prepare阶段 写redolog 并被标记为prepare 实现的话可以在redolog开头写一条特殊的日志记录
	- commit阶段 保存binlog  最后写一条特殊的commit记录到redolog标志事务提交+binlog成功保存

##### Q：sql慢查询优化
[MySQL慢查询优化、索引优化、以及表等优化总结 – mikechen](https://mikechen.cc/3305.html)
- 首先从日志中找出慢sql语句
- explain语句分析 重点关注以下字段
	- type 何种类型的查询
	- key 实际使用到的索引
	- rows 预计扫描的行数
	- 
- 索引优化
	- 经常被where orderby使用的应该设置索引
	- 覆盖索引优化  频繁用a查b c就可以将(a,b,c)建一个索引
	- 避免索引失效  
		- 左模糊查询
		- 对索引进行了函数、表达式计算、OR、类型转换
	- 主键自增 如果是随机的主键 那么插入数据将变成随机io 并且会移动页中数据
	- 索引设置成not null  null值不可比较处理会很麻烦

##### Q：什么是幻读，如何解决
- 幻读是指事务中同样一条查询记录在事务两个时间点执行 查询出来的结果集不同
- 对于一致读使用mvcc
- 对于for update 当前读使用间隙锁

##### Q：数据库三大范式
[MySQL 三大范式 | MySQL 技术论坛 (learnku.com)](https://learnku.com/articles/35660)
- 第一范式 每一列都是不可拆解的原子值，如果系统经常访问地址中属性的城市，那么地址就要拆分成城市 省份等多个部分
- 第二范式 每一列依赖于主键 订单号+商品编号其他列为商品的信息 这样就违背了第二范式 因为订单号和商品其他信息没有直接相关 就要拆成两个表 商品编号作为商品信息的主键
- 第三范式 每个属性要与主键直接相关 而不是间接相关![[Pasted image 20231005204531.png]]

### 事务
##### Q：mysql的事务具有哪些特性？
- A：原子性，即事务中的所有操作要么全部完成要么全部失败回滚，不存在执行到一半的中间状态
- C：一致性，是指数据库能从一个正确的状态转移到另一个正确的状态 C是开发者的责任 C也是数据库最终的目标
- I：隔离性，多个事务并发访问数据库时，一个事务看不到其他事务的运行效果，以及中间状态
- D：持久性，一旦事务被提交，它对数据库的更改就是永久的。即使在系统崩溃后，数据库应该能够恢复到崩溃前的状态
##### Q：事务隔离级别有哪几种？分别是什么？
- 读未提交 RU，一个事务还没提交就会被其他事务看到(**脏读**)
- 读已提交 RC，一个事务提交以后，他做的变更才能被其他事务看到(**不可重复读**)
- 可重复读 RR，一个事务在整个过程中看到的数据从开头都结尾都是保持一致的(**幻读**)
- 串行化，当多个事务对同一条记录发生读写操作时，发生冲突的时候，后访问的事务必须等前一个事务执行完成
##### Q：什么是幻读、脏读、不可重复读、写偏斜
- 幻读，即读出来的结果集数量不同 第一次查询返回了三行 第二次查询返回了四行
- 脏读，一个事务读取到另一个事务未提交的数据
- 不可重复读，一个事务多次读取同一数据返回的结果不同
- 写偏斜，两个事务在读取相同的数据时，并根据这一数据进行数据库的修改操作，导致一个事务的修改被保留，另一个事务的修改被覆盖
##### Q：在可重复读隔离级别下，A事务在执行查询的过程中，B事务在A查询的范围里插入一条新数据，会发生什么，数据能插入成功吗？这种情况下，加的是什么锁？
- 在innoDB存储引擎中 如果A事务执行的是快照读 那么B事务是可以插入成功的 但对于A事务来说是不可见的
- 如果A事务执行的是当前读 那么A事务会在查询范围内上**next-key lock(记录锁+间隙锁)**
##### Q：在真实的业务场景(可重复读隔离级别)对一个表的delete操作应该注意什么 delete加的是什么锁？
- 小批量的删除会给记录上行锁 也就是记录锁
- 大规模的删除可能会上表锁 所以大规模的删除要分批删除 或者会阻塞其他事务
##### Q：InnoDB的MVCC是怎么实现的？
- 首先每一行数据会维护一个db_trx_id字段用于记录最新修改并提交这行数据的事务 以及roll_back指针用于记录这行数据的版本链
- 在可重复读的情况下 会在事务启动时生成一个read view 一个read view维护了最小的活跃事务id 以及最大的活跃事务id 以及未提交的事务id
- 读取一行数据如果他的trx_id小于min_id则是可见的 大于max_id不可见 否则就要判断是否在未提交事务id集合中  如果是的话就要去版本链中找到第一个可见的版本数据
##### Q：可重复读 和 读已提交是怎么实现的？
- 可重复读会在事务一开始就生成一个read view  read view中维护了当前的事务id 以及活跃的事务最小、最大id 以及活跃未提交的事务id列表  并在这个事务中查询数据都会受到read view的限制 具体而言就是查询一行数据要判断他的trx_id 当他小于min_id或者小于max_id并不在活跃id列表中才可见 否则就要去版本链中找到第一个可见的
- 读已提交则是在每一次查询都要创建一个read view

### 索引
##### Q：Mysql B+树最多多少层
- 最多3-4层
- 超过了会影响效率增加io次数  但是不会超过吧 4层b+树大概存储了3百多亿的数据行索引

##### Q：Innodb为什么选择B+ tree作为索引
- b+树只在叶子节点存储数据，并且高度固定 相较于b树而言相同的磁盘io能查询更多的节点
- b+树的叶子节点采用双链表 更适合范围查询

##### Q：最左前缀原则
- 建立(a,b,c)这样的联合索引 使用联合索引进行查询时的查询条件需要时索引的前缀 例如 a  ab abc都能查 b 则不能
- 建立a,b,c联合索引 是先按a排序 再按b排序 再按c排序 也就是说当a相同时 才会用到b 然后再用到c

##### Q：什么时候需要建立索引
- 维护索引需要占用大量的物理空间 增删改也需要去动态维护索引需要耗费时间
- 如果一个字段会被频繁的用于where查询  或者经常用于orderby则有必要建索引
- 如果字段中含有大量重复数据则不需要建立索引  经常修改的字段也不用创建索引因为要动态维护索引字段 浪费时间

##### Q：如何优化索引
- 使用前缀索引优化字符串索引 节省空间
- 覆盖索引 建立联合索引使得二级索引中就有要查询信息而不用回表再查一次
- 主键设置递增且非空  如果主键不设置递增的话那么插入一条记录就可能要去调整b+树是随机io  而自增的话插入一条记录则是追加操作
- 防止索引失效

##### Q：B+ Tree 和 B Tree的区别
- 在B+Tree中只有叶子节点有数据 其他节点只有索引
- 而B树每隔节点要放索引也要放数据 因此非叶子节点能存放更多索引 所以B+树要更矮胖一点 所以io次数也更少
- b+树插入删除对结构改动的很小效率更高
- b+树的叶子节点通过链表链接在一起 更适合范围查询

##### Q：什么时候索引失效
- 使用左或者左右模糊查询
	- 索引比较是通过前缀比较的 左模糊查询 那么就不可比较了
- 对索引使用函数 或者对索引使用表达式
	- 比较的是索引 对索引使用了函数 就不再是可比较的值了
- 对索引进行了隐式转换  
	- 存的时候索引类型是int 查询的时候转换成float了
- 联合索引没有遵循最左匹配原则
	- 联合索引是按照 a再b再c排序 所以如果直接拿b作为索引会失效
- 在WHERE子句中OR前是索引列 or后不是索引列
- **总得来说记住索引就是一颗按照索引列排序的有序结构就可以 联合索引则是先a再b再c**

##### Q：如果一个表有一个性别字段(枚举值)，该给这个字段加索引吗？
- 因为性别只有两种情况，如果给性别字段建索引，因为他索引选择性很低，使用这个二级索引查主键可能只能得到一半，也就是不能筛选掉足够多的数据
- 这一半还要通通走一遍主键索引拿到真实数据，不如直接走一遍全表扫描