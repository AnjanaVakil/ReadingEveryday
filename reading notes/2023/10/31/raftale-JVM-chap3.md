# 概述

Garbage Collection(GC)不是Java的伴生产物，Lisp是第一门开始使用内存动态分配和垃圾收集技术的预言。

程序计数器、虚拟机栈、本地方法栈都是随着线程而生而死的，每一个栈帧分配多少内存是在类结构确定下来就已知。

Java堆和方法区则具有不确定性，垃圾收集器关注的就是这部分内存如何管理。

# 对象已死？

## 引用计数算法

对象中添加一个引用计数器，每当有一处引用就加1，引用失效就减1。当引用为0时则说明对象不再被使用。

但主流的JVM并没有使用引用计数算法，因为引用计数存在循环引用的问题。

## 可达性分析算法

当前主流的语言的GC都是使用的可达性分析算法来判定对象是否存活的。

可达性分析是看某个对象如果不能到达GC Roots根对象，那这个对象就是不再使用的。

GC Roots包括：

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈引用的对象
5. 虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，还有系统加载器
6. 所有被synchronized持有的对象
7. 反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
8. 临时性加入的一些对象


## 再谈引用

Java中的引用不只是被引用和未被引用这两种单纯的状态。

Java中引用分为以下四种：

1. 强引用，Strongly Reference：强引用存在，就永远不会回收
2. 软引用，Soft Reference：有用但非必须的对象。OOM前会进行回收。
3. 弱引用，Weak Reference：只能存活到下一次垃圾回收时
4. 虚引用，Phantom Reference：设置虚引用的唯一目的就是为了这个对象被回收时收到一个系统通知。

分成这些的根本原因是JVM希望能灵活的处理对象的回收，当内存空间还足够时，有些对象是可以保留的，而当内存空间不够时，这些对象就可以抛弃掉。很多系统的缓存功能都符合这样的场景。

# 垃圾收集算法

## 分代收集理论

当前商业JVM的垃圾收集器，大都遵循了分代收集的理论进行设计，分代收集建立在两个分代假说之上：

1. 弱分代假说：绝对多数对象都是朝生夕灭的；
2. 强分代假说：熬过多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用仅占少数

前两个假说暗示了对象的两个极端，所以自然就想到将对象按类别集中和分开存储。对于生命周期短的对象，GC就可以选择关注如何保留少量的存活而不是去标记那些大量将要被被回收的对象；对于生命周期长的对象，GC就可以以较低的频率来回收它们。

因此一般来说堆被划分为新生代和老年代。新生代每次GC时都有大批对象死去，而每次回收后存储的少量对象，会逐步晋升到老年代去。

新生代的对象可能会被老年代的对象引用，所以每次Young GC时，还需要遍历老年代的所有对象确保可达性分析的正确性，但这个遍历增加了性能负担。

跨代引用假说可以避免为了少量的跨代去扫描整个老年代，因此只需要在新生代上建立一个全局的数据结构，这个结构把老年代划分为若干小块，标记出老年代的哪一块内存会存在跨代引用。此后当发生Young GC时，只要包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。



## 标记-清除算法

mark sweep

标记-清除算法很好理解，将需要回收的对象进行标记，然后进行统一回收。

缺点：

1. 执行效率不稳定：包含了大量标记和清除的动作，需要标记的对象越多越耗时；
2. 内存空间碎片化：标记是随机的，所以清理会造成内存空间碎片化

## 标记-复制算法

标记-复制算法解决了「标记-清除」算法的执行效率不稳定和内存空间碎片化的缺点，但引出了新的缺点：空间浪费。

1. 半区复制：内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完时，就将还存活的对象复制到另一块上，再把这一块内存空间一次清理掉。

1. 1. 缺点是浪费一般的空间

1. Appel式回收：新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor。默认Eden和Survivor的大小比例为8:1，只浪费10%的空间。Survivor空间不足时，老年代会有兜底。

## 标记-整理算法

老年代不会选用「标记-整理」算法，因为对象存活率较高时就需要进行较多的复制操作，效率将会降低。或者需要额外的空间进行分配担保。

标记-整理是一种针对老年代的移动式的回收算法，它让所有存活的对象都向空间一端移动，然后清理掉边界以外死亡的对象。

缺点：移动存活对象并更新所有引用这些对象的地方是一种负重的操作。这种对象移动必须全程暂停用户应用程序才能进行。这样的停顿被描述为「Stop the world」。

尽管有缺点，但移动式的算法又是必须的，否则内存分配会更复杂，移动式是回收时复杂。

1. 从GC的停顿时间来看：不移动停顿时间短，移动停顿时间长
2. 从整个程序的吞吐量来看：移动对象会更划算，因为内存分配和访问比GC的频率高，所以不移动时采用复杂的内存分配，效率会更低。

# HotSpot的算法细节实现

## 根节点枚举

可达性分析中，GC Roots集合非常重要，但GC Roots越来越大，检索出那些对象是GC Roots是非常耗时的，个检索就是根节点枚举。枚举根节点是必须要停顿的， 否则不能保证数据的一致性。

为了解决这个问题，我们可以以空间换时间，使用一个OopMap的数据结构来保存GC Roots并随时更新。

## 安全点

又了OopMap，HotSpot可以快速准确的完成GC Roots的枚举，但是OopMap如何更新的频繁，那需要大量的额外存储空间。

所以HotSpot并没有为每条指令都生成OopMap，而只是在特定位置记录了OopMap，这些特定位置也被称为安全点（SafePoint。程序必须运行到了安全点才能够暂停更新GC Roots并开始开始GC，所以安全点的选择是一种trade off，即不能让GC等待太长时间，也不能太过频繁导致增加过多的额外存储。

安全点的位置基本上是以「是否具有让程序长时间执行的特征」为标准选定的，长时间执行的最明显特征就是指令序列的复用，例如：

1. 循环的末尾；
2. 可能抛出异常的位置；
3. 方法临返回前的位置

选用这些点的意思是尽可能的不让某个位置的安全点需要执行时间太长才能到达，这导致其他安全点都在等待它的执行，而指令重复点可以很快到达并且可以随时挂起，所以非常适合作为安全点。



为了让所有线程都跑到最近的安全点，然后停顿下来，JVM采用的是主动式中断。通过设置一个标志位，各个线程执行过程时不断轮询这个标志，一旦发现中断标志为真时就在自己最近的安全点主动中断挂起。
