# Java语言中的线程安全

### 

## 线程安全的实现方法

### 互斥同步

**同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用**（或者是一些，当使用信号量的时候）。互斥是实现同步的一种手段。

Java最基本的互斥同步手段就是synchronized关键字，特性：可重入、互斥、非公平锁。获取锁需要等待会使线程进入block状态，由于Java的线程是内核线程1:1的，阻塞或唤醒线程需要操作系统的帮忙，在用户态和内核态之间进行切换，这个状态切换需要耗费很多的处理器时间。当然，JVM本身会有一些优化，比如在通知操作系统阻塞线程之前进行一段自选等待过程。但synchronized的使用还是需要谨慎，它对性能的开销影响非常大。



高级锁Lock会有一些高级特性：等待可中断、公平锁、锁可以绑定多个条件，但ReentrantLock和synchronized的性能差不多。

### 非阻塞同步

互斥同步是一种悲观锁策略，随着硬件指令集的发展，我们又了另外一个选择：基于冲突检测的乐观并发机制，通俗的讲，就是不管风险，先进行操作，如果没有其他线程争用共享数据，那么线程就操作成功了；如果有争用，那说明产生了冲突，再进行补偿，最常用的补偿就是重试。这种乐观并发机制不需要阻塞线程挂起，这种同步操作也被称为非阻塞同步（Non-Blocking Synchronization）和无锁编程（Lock-Free）。

乐观并发策略需要硬件支持「操作」和「冲突检测」的原子性。硬件保证某些从语义上看起来需要多次操作的行为可以通过一条处理器指令就能完成，这类指令常用的有：

1. Test-and-Set
2. Fetch-and-Increment
3. Swap
4. Compare-And-Swap
5. Load-Linked/Store-Conditional, LL/SC



CAS不再介绍了，JUC就大量使用了CAS。

但CAS有一个很明显的问题：ABA问题。ABA问题的解决方法 就是在CAS的时候引入版本号，然后比较的时候需要带上版本号。Juc提供了一个带有标记的原子引用类AtomicStampedReference来解决ABA问题。

### 无同步方案

要保证线程安全，也并非一定要进行阻塞或者非阻塞同步，那就是避免共享数据。

# 锁优化

JVM优化线程的阻塞和唤醒。

## 自旋锁和自适应自旋

当物理机有多个处理器或者多个处理器核心，如果线程遇到阻塞，等待锁的线程可以执行一个忙等待（自旋）来等待持有锁的线程释放，来避免线程挂起和恢复（上下文切换）。

JDK6+默认开启自旋锁，自旋锁对处理器有要求，且占用处理器时间，自旋会产生性能浪费，自旋时间短还好。自旋次数默认是十次。

自适应自旋是JVM不固定自旋次数，而是看锁的状态和环境来自行判断。

## 锁消除

有一些代码虽然使用了synchronized，但根本不可能出现共享数据的竞争，所以JVM在运行时检测到某段同步的代码根本不可能存在共享数据竞争时就消除同步的使用。

锁消除的主要判定依据来源于逃逸分析。

## 锁粗化

锁的同步代码块并不是越小越好，如果本来一块连续的同步被分割为很多小的同步，那分割后的性能反而更低。比如加锁操作是在循环体中出现的。JVM扩大同步范围不影响功能，但提高了性能。

## 偏向锁和轻量级锁

偏向锁的目的是消除无竞争下的同步原语。

轻量级锁是避免锁进入阻塞状态，通过自旋锁来等待。

重量级锁就是线程阻塞了。


当锁对象第一次被线程获取的时候，虚拟机会把对象头的标志位设置为01，偏向模式设置为1，表示进入偏向模式，并使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Work中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步代码块时，虚拟机都可以不再进行任何同步操作。

一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就宣告结束。有竞争时，偏向锁就升级为轻量级锁，如果出现两条以上的线程争用同一个锁，就膨胀为重量级锁。



适用场景和优点：

1. 偏向锁：适用于只有一个线程访问同步块的场景

1. 1. 加锁和解锁都不需要CAS和阻塞

1. 轻量级锁：追求响应时间，同步块执行速度非常快

1. 1. CAS失败后自旋，避免线程阻塞

1. 重量级锁：追求吞吐量，同步块执行时间较长

1. 1. 线程阻塞，上下文切换开销大



Java15开始已经废弃了偏向锁。
