## Java NIO

Java NIO属于IO多路复用模型。

### IO多路复用

为了提高性能，操作系统引入了一种新的系统调用，专门用于查询IO文件描述符（含socket连接）的就绪状态。

目前支持IO多路复用技术有：

* Linux: select、poll、epoll
* Mac: kqueue
* Windows: select

通过系统调用，一个用户进程/线程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程/线程，用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。

IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。

发起一个多路复用IO的read操作的系统调用，流程如下：

1、选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。

2、就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。

3、用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。

4、复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。

通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用`epoll系统调用`实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。

Java NIO类库包含以下三个核心组件：

* Channel（通道）
* Buffer（缓冲区）
* Selector（选择器）

### NIO VS OIO

在Java中，NIO和OIO的区别主要体现在三个方面：

1、OIO是面向流（Stream Oriented）的，NIO是面向缓冲区（Buffer Oriented）的。

在一般的OIO操作中，面向字节流或字符流的IO操作总是以流式的方式顺序地从一个流（Stream）中读取一个或多个字节，因此，我们不能随意改变读取指针的位置。

在NIO操作中则不同，NIO中引入了Channel和Buffer的概念。面向缓冲区的读取和写入只需要从通道读取数据到缓冲区中，或将数据从缓冲区写入通道中。NIO不像OIO那样是顺序操作，它可以随意读取Buffer中任意位置的数据。

2、OIO的操作是阻塞的，而NIO的操作是非阻塞的。

OIO操作都是阻塞的。例如，调用一个read方法读取一个文件的内容，调用read的线程就会被阻塞，直到read操作完成。

在NIO模式中，当调用read方法时，如果此时有数据，则read读取数据并返回；如果此时没有数据，则read也会直接返回，而不会阻塞当前线程。

NIO的非阻塞是通过通道和通道的多路复用技术实现的。

3、OIO没有选择器（Selector）的概念，而NIO有选择器的概念。

NIO的实现是基于底层选择器的系统调用的，所以NIO需要底层操作系统提供支持；而OIO不需要用到选择器。

IO多路复用编程的步骤：

1、把通道注册到选择器中

2、通过选择器所提供的事件查询（select）方法来查询这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。